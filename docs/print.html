<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>AnyFS Backend Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for anyfs-backend: core traits and types for pluggable virtual filesystem backends in Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "searchindex-73facf0e.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-e4cbe513.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">AnyFS Backend Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/DK26/anyfs-backend" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="anyfs-backend-guide"><a class="header" href="#anyfs-backend-guide">AnyFS Backend Guide</a></h1>
<p><strong>anyfs-backend</strong> is the foundational crate for the AnyFS ecosystem. It provides a trait-based abstraction for filesystem operations, allowing you to:</p>
<ul>
<li>Write code that works with any filesystem backend</li>
<li>Create middleware layers that add cross-cutting functionality</li>
<li>Build FUSE filesystems with a clean, type-safe API</li>
</ul>
<h2 id="who-is-this-guide-for"><a class="header" href="#who-is-this-guide-for">Who Is This Guide For?</a></h2>
<ul>
<li><strong>Backend implementers</strong>: You want to create a new filesystem backend (S3, Google Drive, in-memory, etc.)</li>
<li><strong>Middleware authors</strong>: You want to add logging, caching, encryption, or other features as composable layers</li>
<li><strong>Library users</strong>: You want to understand how to use anyfs effectively</li>
</ul>
<h2 id="what-youll-learn"><a class="header" href="#what-youll-learn">What You’ll Learn</a></h2>
<h3 id="implementing-a-backend"><a class="header" href="#implementing-a-backend"><a href="tutorials/backend/README.html">Implementing a Backend</a></a></h3>
<p>Step-by-step guide to implementing a complete filesystem backend, from basic file operations to full POSIX support.</p>
<h3 id="implementing-middleware"><a class="header" href="#implementing-middleware"><a href="tutorials/middleware/README.html">Implementing Middleware</a></a></h3>
<p>How to create reusable middleware layers using the Tower-inspired Layer pattern.</p>
<h2 id="quick-example"><a class="header" href="#quick-example">Quick Example</a></h2>
<pre class="playground"><code class="language-rust">use anyfs_backend::{Fs, FsError};
use std::path::Path;

// Write a generic function that works with ANY backend
fn copy_file&lt;B: Fs&gt;(fs: &amp;B, src: &amp;Path, dst: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
    let content = fs.read(src)?;
    fs.write(dst, &amp;content)?;
    Ok(())
}

// Use with any backend that implements Fs
fn main() {
    let fs = my_backend::MyFs::new();
    copy_file(&amp;fs, Path::new("/src.txt"), Path::new("/dst.txt")).unwrap();
}</code></pre>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<ol>
<li><strong>Trait-based</strong>: All operations are defined as traits, enabling generic code</li>
<li><strong>Layered</strong>: Traits are organized in layers (Fs → FsFull → FsFuse → FsPosix)</li>
<li><strong>Composable</strong>: Middleware layers can be stacked to add functionality</li>
<li><strong>Thread-safe</strong>: All traits require <code>Send + Sync</code> for concurrent access</li>
<li><strong>Error-rich</strong>: Detailed error types with full context</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>Add <code>anyfs-backend</code> to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
anyfs-backend = "0.1"
</code></pre>
<h2 id="using-a-filesystem-backend"><a class="header" href="#using-a-filesystem-backend">Using a Filesystem Backend</a></h2>
<p>All backends implement the <code>Fs</code> trait (or higher-level traits). Write generic code against these traits:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{Fs, FsError};
use std::path::Path;

fn list_files&lt;B: Fs&gt;(fs: &amp;B, dir: &amp;Path) -&gt; Result&lt;Vec&lt;String&gt;, FsError&gt; {
    let mut names = Vec::new();
    for entry in fs.read_dir(dir)? {
        let entry = entry?;
        names.push(entry.name);
    }
    Ok(names)
}
<span class="boring">}</span></code></pre>
<h2 id="creating-a-simple-backend"><a class="header" href="#creating-a-simple-backend">Creating a Simple Backend</a></h2>
<p>Here’s a minimal in-memory filesystem:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsRead, FsWrite, FsDir, FsError, Metadata, DirEntry, FileType, Permissions, ReadDirIter};
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::sync::RwLock;

pub struct SimpleFs {
    files: RwLock&lt;HashMap&lt;PathBuf, Vec&lt;u8&gt;&gt;&gt;,
}

impl SimpleFs {
    pub fn new() -&gt; Self {
        Self { files: RwLock::new(HashMap::new()) }
    }
}

impl FsRead for SimpleFs {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        self.files.read().unwrap()
            .get(path)
            .cloned()
            .ok_or_else(|| FsError::NotFound { path: path.to_path_buf() })
    }

    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        let files = self.files.read().unwrap();
        let content = files.get(path)
            .ok_or_else(|| FsError::NotFound { path: path.to_path_buf() })?;
        
        Ok(Metadata {
            path: path.to_path_buf(),
            file_type: FileType::File,
            len: content.len() as u64,
            permissions: Permissions::default(),
            ..Default::default()
        })
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; bool {
        self.files.read().unwrap().contains_key(path)
    }
}

impl FsWrite for SimpleFs {
    fn write(&amp;self, path: &amp;Path, content: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        self.files.write().unwrap().insert(path.to_path_buf(), content.to_vec());
        Ok(())
    }

    fn remove_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.files.write().unwrap()
            .remove(path)
            .map(|_| ())
            .ok_or_else(|| FsError::NotFound { path: path.to_path_buf() })
    }
}

// FsDir implementation would go here...
<span class="boring">}</span></code></pre>
<h2 id="using-middleware-layers"><a class="header" href="#using-middleware-layers">Using Middleware Layers</a></h2>
<p>Wrap any backend with middleware:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{Fs, Layer};

// Assuming LoggingLayer is a middleware that logs operations
let fs = SimpleFs::new();
let fs = LoggingLayer::new("MyApp").layer(fs);

// Now all operations are logged
fs.write(Path::new("/hello.txt"), b"Hello!").unwrap();
<span class="boring">}</span></code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="#trait-hierarchy">Trait Hierarchy</a> - Understand the layer system</li>
<li><a href="tutorials/backend/README.html">Backend Tutorial</a> - Complete backend implementation guide</li>
<li><a href="tutorials/middleware/README.html">Middleware Tutorial</a> - Create reusable layers</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="trait-hierarchy"><a class="header" href="#trait-hierarchy">Trait Hierarchy</a></h1>
<p>The anyfs-backend crate organizes filesystem operations into a layered hierarchy of traits. Each layer adds more capabilities.</p>
<h2 id="the-four-layers"><a class="header" href="#the-four-layers">The Four Layers</a></h2>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│  Layer 4: FsPosix                                           │
│  Full POSIX semantics with handles and locks                │
│  = FsFuse + FsHandles + FsLock + FsXattr                    │
├─────────────────────────────────────────────────────────────┤
│  Layer 3: FsFuse                                            │
│  FUSE-compatible with inode operations                      │
│  = FsFull + FsInode                                         │
├─────────────────────────────────────────────────────────────┤
│  Layer 2: FsFull                                            │
│  Complete filesystem with links, permissions, stats         │
│  = Fs + FsLink + FsPermissions + FsSync + FsStats           │
├─────────────────────────────────────────────────────────────┤
│  Layer 1: Fs                                                │
│  Basic file operations                                      │
│  = FsRead + FsWrite + FsDir                                 │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="layer-1-fs-basic-operations"><a class="header" href="#layer-1-fs-basic-operations">Layer 1: Fs (Basic Operations)</a></h2>
<p>The minimum for a functional filesystem.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>FsRead</code></td><td>Read files, get metadata, check existence</td></tr>
<tr><td><code>FsWrite</code></td><td>Write files, delete files</td></tr>
<tr><td><code>FsDir</code></td><td>List, create, remove directories; rename</td></tr>
</tbody>
</table>
</div>
<p><strong>Use <code>Fs</code> when:</strong> You need basic file I/O and don’t care about permissions, symlinks, or advanced features.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn backup&lt;B: Fs&gt;(fs: &amp;B, src: &amp;Path, dst: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
    let data = fs.read(src)?;
    fs.write(dst, &amp;data)
}
<span class="boring">}</span></code></pre>
<h2 id="layer-2-fsfull-complete-filesystem"><a class="header" href="#layer-2-fsfull-complete-filesystem">Layer 2: FsFull (Complete Filesystem)</a></h2>
<p>Adds features most real filesystems need.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>FsLink</code></td><td>Symbolic and hard links</td></tr>
<tr><td><code>FsPermissions</code></td><td>Set permissions and ownership</td></tr>
<tr><td><code>FsSync</code></td><td>Flush writes to storage</td></tr>
<tr><td><code>FsStats</code></td><td>Filesystem statistics (space usage)</td></tr>
</tbody>
</table>
</div>
<p><strong>Use <code>FsFull</code> when:</strong> You need symlinks, permissions, or disk usage stats.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_symlink&lt;B: FsFull&gt;(fs: &amp;B, target: &amp;Path, link: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
    fs.symlink(target, link)
}
<span class="boring">}</span></code></pre>
<h2 id="layer-3-fsfuse-fuse-support"><a class="header" href="#layer-3-fsfuse-fuse-support">Layer 3: FsFuse (FUSE Support)</a></h2>
<p>Adds inode-based operations for FUSE implementations.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>FsInode</code></td><td>Path↔inode conversion, lookup by inode</td></tr>
</tbody>
</table>
</div>
<p><strong>Use <code>FsFuse</code> when:</strong> Building a FUSE filesystem that operates on inodes.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_child&lt;B: FsFuse&gt;(fs: &amp;B, parent_inode: u64, name: &amp;str) -&gt; Result&lt;u64, FsError&gt; {
    fs.lookup(parent_inode, name)
}
<span class="boring">}</span></code></pre>
<h2 id="layer-4-fsposix-full-posix"><a class="header" href="#layer-4-fsposix-full-posix">Layer 4: FsPosix (Full POSIX)</a></h2>
<p>Complete POSIX semantics.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>FsHandles</code></td><td>Open files, read/write at offset</td></tr>
<tr><td><code>FsLock</code></td><td>File locking (shared/exclusive)</td></tr>
<tr><td><code>FsXattr</code></td><td>Extended attributes</td></tr>
</tbody>
</table>
</div>
<p><strong>Use <code>FsPosix</code> when:</strong> You need file handles, locking, or extended attributes.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn locked_write&lt;B: FsPosix&gt;(fs: &amp;B, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
    let handle = fs.open(path, OpenFlags::WRITE | OpenFlags::CREATE)?;
    fs.lock(handle, LockType::Exclusive)?;
    fs.write_at(handle, 0, data)?;
    fs.unlock(handle)?;
    fs.close(handle)
}
<span class="boring">}</span></code></pre>
<h2 id="choosing-the-right-trait-bound"><a class="header" href="#choosing-the-right-trait-bound">Choosing the Right Trait Bound</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Your needs</th><th>Use this bound</th></tr>
</thead>
<tbody>
<tr><td>Basic read/write/list</td><td><code>Fs</code></td></tr>
<tr><td>+ symlinks, permissions, stats</td><td><code>FsFull</code></td></tr>
<tr><td>+ inode operations (FUSE)</td><td><code>FsFuse</code></td></tr>
<tr><td>+ file handles, locking</td><td><code>FsPosix</code></td></tr>
</tbody>
</table>
</div>
<h2 id="automatic-implementation"><a class="header" href="#automatic-implementation">Automatic Implementation</a></h2>
<p>The composite traits (<code>Fs</code>, <code>FsFull</code>, <code>FsFuse</code>, <code>FsPosix</code>) are automatically implemented via blanket impls. You only implement the component traits:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// You implement these:
impl FsRead for MyBackend { ... }
impl FsWrite for MyBackend { ... }
impl FsDir for MyBackend { ... }

// This is automatic:
// impl Fs for MyBackend {}  // ← Provided by blanket impl
<span class="boring">}</span></code></pre>
<h2 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h2>
<p>All traits require <code>Send + Sync</code>. This means:</p>
<ul>
<li>Methods take <code>&amp;self</code>, not <code>&amp;mut self</code></li>
<li>Use interior mutability (<code>RwLock</code>, <code>Mutex</code>) for mutable state</li>
<li>Safe for concurrent access from multiple threads</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyBackend {
    // Use RwLock for mutable state
    files: RwLock&lt;HashMap&lt;PathBuf, Vec&lt;u8&gt;&gt;&gt;,
}

impl FsRead for MyBackend {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        // Acquire read lock
        self.files.read().unwrap().get(path).cloned()
            .ok_or_else(|| FsError::NotFound { path: path.to_path_buf() })
    }
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="implementing-a-backend-1"><a class="header" href="#implementing-a-backend-1">Implementing a Backend</a></h1>
<p>This tutorial walks you through implementing a complete filesystem backend from scratch. By the end, you’ll have a working in-memory filesystem that implements all traits up to <code>FsPosix</code>.</p>
<h2 id="what-youll-build"><a class="header" href="#what-youll-build">What You’ll Build</a></h2>
<p>An in-memory filesystem (<code>TutorialFs</code>) that:</p>
<ul>
<li>Stores files and directories in memory</li>
<li>Supports symlinks</li>
<li>Tracks permissions and timestamps</li>
<li>Provides inode-based access for FUSE</li>
<li>Implements file handles and locking</li>
</ul>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>Basic Rust knowledge (structs, traits, <code>Result</code>)</li>
<li>Understanding of filesystem concepts (files, directories, symlinks)</li>
</ul>
<h2 id="tutorial-structure"><a class="header" href="#tutorial-structure">Tutorial Structure</a></h2>
<p>Each chapter introduces one or more traits:</p>
<ol>
<li><strong><a href="#core-data-structures">Core Data Structures</a></strong> - Design the internal state</li>
<li><strong><a href="#fsread-reading-files">FsRead</a></strong> - Read files and metadata</li>
<li><strong><a href="#fswrite-writing-files">FsWrite</a></strong> - Write and delete files</li>
<li><strong><a href="#fsdir-directory-operations">FsDir</a></strong> - Directory operations</li>
<li><strong><a href="#the-fs-trait">The Fs Trait</a></strong> - Combining the basics</li>
<li><strong><a href="#fslink-symlinks">FsLink</a></strong> - Symlink support</li>
<li><strong><a href="#fsfull-complete-filesystem">FsFull</a></strong> - Permissions, sync, stats</li>
<li><strong><a href="#fsinode-fuse-support">FsInode</a></strong> - FUSE inode operations</li>
<li><strong><a href="#fsposix-full-posix-semantics">FsPosix</a></strong> - Handles and locking</li>
</ol>
<h2 id="running-the-examples"><a class="header" href="#running-the-examples">Running the Examples</a></h2>
<p>Each chapter has runnable example code. Clone the repository and run:</p>
<pre><code class="language-bash">cargo run --example tutorial_backend_complete
</code></pre>
<h2 id="the-end-result"><a class="header" href="#the-end-result">The End Result</a></h2>
<p>After completing this tutorial, you’ll understand:</p>
<ul>
<li>How each trait fits into the hierarchy</li>
<li>What each method should do and return</li>
<li>Error handling conventions</li>
<li>Thread-safety requirements</li>
<li>How blanket implementations work</li>
</ul>
<p>Let’s start with <a href="#core-data-structures">Core Data Structures →</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="core-data-structures"><a class="header" href="#core-data-structures">Core Data Structures</a></h1>
<p>Before implementing any traits, we need to design our internal data structures. These hold the actual filesystem state.</p>
<h2 id="key-design-decisions"><a class="header" href="#key-design-decisions">Key Design Decisions</a></h2>
<h3 id="1-thread-safety"><a class="header" href="#1-thread-safety">1. Thread Safety</a></h3>
<p>All trait methods take <code>&amp;self</code> (not <code>&amp;mut self</code>), so we must use <strong>interior mutability</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ❌ Won't work - traits don't allow &amp;mut self
impl FsWrite for MyFs {
    fn write(&amp;mut self, path: &amp;Path, content: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; { ... }
}

// ✅ Correct - use interior mutability
impl FsWrite for MyFs {
    fn write(&amp;self, path: &amp;Path, content: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let mut files = self.files.write().unwrap();  // RwLock
        files.insert(path.to_path_buf(), content.to_vec());
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<p>We wrap mutable state in <code>RwLock</code> (or <code>Mutex</code>).</p>
<h3 id="2-path-normalization"><a class="header" href="#2-path-normalization">2. Path Normalization</a></h3>
<p>Paths like <code>/foo/bar</code>, <code>/foo//bar</code>, and <code>/foo/./bar</code> should all refer to the same file. Always normalize before using as keys:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn normalize_path(path: &amp;Path) -&gt; PathBuf {
    let mut result = PathBuf::from("/");
    for component in path.components() {
        match component {
            Component::RootDir =&gt; result = PathBuf::from("/"),
            Component::CurDir =&gt; {}  // Skip "."
            Component::ParentDir =&gt; { result.pop(); }  // Handle ".."
            Component::Normal(name) =&gt; { result.push(name); }
            Component::Prefix(_) =&gt; {}  // Windows, skip
        }
    }
    result
}
<span class="boring">}</span></code></pre>
<h3 id="3-inode-design"><a class="header" href="#3-inode-design">3. Inode Design</a></h3>
<p>Even if you only need <code>Fs</code>, designing with inodes from the start makes it easier to add <code>FsFuse</code> later:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FsNode {
    inode: u64,  // Unique identifier
    // ... other fields
}
<span class="boring">}</span></code></pre>
<h2 id="the-fsnode-structure"><a class="header" href="#the-fsnode-structure">The FsNode Structure</a></h2>
<p>Each node in our filesystem (file, directory, or symlink) has:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FileType, Permissions};
use std::path::PathBuf;
use std::time::SystemTime;

/// Represents a single node in the filesystem.
#[derive(Clone)]
struct FsNode {
    /// Type: File, Directory, or Symlink
    file_type: FileType,

    /// File contents (empty for directories)
    content: Vec&lt;u8&gt;,

    /// Permission bits (e.g., 0o644)
    permissions: Permissions,

    /// Symlink target (only for symlinks)
    symlink_target: Option&lt;PathBuf&gt;,

    /// Unique inode number
    inode: u64,

    /// Timestamps
    created: SystemTime,
    modified: SystemTime,
    accessed: SystemTime,
}
<span class="boring">}</span></code></pre>
<h3 id="factory-methods"><a class="header" href="#factory-methods">Factory Methods</a></h3>
<p>Create nodes easily:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsNode {
    fn new_file(content: Vec&lt;u8&gt;, inode: u64) -&gt; Self {
        let now = SystemTime::now();
        Self {
            file_type: FileType::File,
            content,
            permissions: Permissions::from_mode(0o644),  // rw-r--r--
            symlink_target: None,
            inode,
            created: now,
            modified: now,
            accessed: now,
        }
    }

    fn new_directory(inode: u64) -&gt; Self {
        let now = SystemTime::now();
        Self {
            file_type: FileType::Directory,
            content: Vec::new(),
            permissions: Permissions::from_mode(0o755),  // rwxr-xr-x
            symlink_target: None,
            inode,
            created: now,
            modified: now,
            accessed: now,
        }
    }

    fn new_symlink(target: PathBuf, inode: u64) -&gt; Self {
        let now = SystemTime::now();
        Self {
            file_type: FileType::Symlink,
            content: Vec::new(),
            permissions: Permissions::from_mode(0o777),  // lrwxrwxrwx
            symlink_target: Some(target),
            inode,
            created: now,
            modified: now,
            accessed: now,
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="the-inner-state"><a class="header" href="#the-inner-state">The Inner State</a></h2>
<p>All mutable state goes in a struct wrapped by <code>RwLock</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use std::path::PathBuf;
use anyfs_backend::{Handle, OpenFlags, LockType};

struct TutorialFsInner {
    /// Maps normalized paths to nodes
    nodes: HashMap&lt;PathBuf, FsNode&gt;,

    /// Maps inodes to paths (for inode-based lookups)
    inode_to_path: HashMap&lt;u64, PathBuf&gt;,

    /// Next available inode number
    next_inode: u64,

    /// Open file handles (for FsHandles)
    handles: HashMap&lt;Handle, HandleState&gt;,

    /// Next available handle ID
    next_handle: u64,

    /// Total filesystem size for stats
    total_size: u64,
}

/// State for an open file handle.
struct HandleState {
    path: PathBuf,
    flags: OpenFlags,
    locked: Option&lt;LockType&gt;,
}
<span class="boring">}</span></code></pre>
<h2 id="the-public-backend-type"><a class="header" href="#the-public-backend-type">The Public Backend Type</a></h2>
<p>The main struct wraps everything in <code>Arc&lt;RwLock&lt;_&gt;&gt;</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, RwLock};

/// Our tutorial filesystem backend.
pub struct TutorialFs {
    inner: Arc&lt;RwLock&lt;TutorialFsInner&gt;&gt;,
}

impl TutorialFs {
    pub fn new() -&gt; Self {
        let mut nodes = HashMap::new();
        let mut inode_to_path = HashMap::new();

        // Always create root directory with inode 1 (ROOT_INODE)
        use anyfs_backend::ROOT_INODE;
        let root = FsNode::new_directory(ROOT_INODE);
        nodes.insert(PathBuf::from("/"), root);
        inode_to_path.insert(ROOT_INODE, PathBuf::from("/"));

        Self {
            inner: Arc::new(RwLock::new(TutorialFsInner {
                nodes,
                inode_to_path,
                next_inode: 2,  // Start after ROOT_INODE
                next_handle: 1,
                handles: HashMap::new(),
                total_size: 100 * 1024 * 1024,  // 100 MB virtual size
            })),
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="helper-methods"><a class="header" href="#helper-methods">Helper Methods</a></h2>
<p>Add utility methods for common operations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TutorialFs {
    /// Normalize a path for consistent storage and lookup.
    fn normalize_path(path: &amp;Path) -&gt; PathBuf {
        // Implementation from above
    }

    /// Allocate a new inode number.
    fn alloc_inode(inner: &amp;mut TutorialFsInner) -&gt; u64 {
        let inode = inner.next_inode;
        inner.next_inode += 1;
        inode
    }

    /// Allocate a new file handle.
    fn alloc_handle(inner: &amp;mut TutorialFsInner) -&gt; Handle {
        let id = inner.next_handle;
        inner.next_handle += 1;
        Handle(id)
    }
}
<span class="boring">}</span></code></pre>
<h2 id="converting-to-metadata"><a class="header" href="#converting-to-metadata">Converting to Metadata</a></h2>
<p>The traits return <code>Metadata</code> structs. Add a conversion method:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::Metadata;

impl FsNode {
    fn to_metadata(&amp;self, path: &amp;Path) -&gt; Metadata {
        Metadata {
            path: path.to_path_buf(),
            file_type: self.file_type,
            len: self.content.len() as u64,
            permissions: self.permissions.clone(),
            created: Some(self.created),
            modified: Some(self.modified),
            accessed: Some(self.accessed),
            inode: Some(self.inode),
            uid: Some(1000),
            gid: Some(1000),
            nlink: Some(1),
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>We now have:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>FsNode</code></td><td>Represents a file, directory, or symlink</td></tr>
<tr><td><code>TutorialFsInner</code></td><td>All mutable state</td></tr>
<tr><td><code>TutorialFs</code></td><td>Public backend with <code>Arc&lt;RwLock&lt;Inner&gt;&gt;</code></td></tr>
</tbody>
</table>
</div>
<p>Next, we’ll implement <a href="#fsread-reading-files">FsRead →</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="fsread-reading-files"><a class="header" href="#fsread-reading-files">FsRead: Reading Files</a></h1>
<p><code>FsRead</code> provides read-only access to files and metadata. This is the foundation for all filesystem access.</p>
<h2 id="the-trait"><a class="header" href="#the-trait">The Trait</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsRead: Send + Sync {
    /// Read the entire contents of a file.
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;

    /// Get metadata (size, type, timestamps, etc.).
    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt;;

    /// Check if a path exists.
    fn exists(&amp;self, path: &amp;Path) -&gt; bool;
}
<span class="boring">}</span></code></pre>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<h3 id="read---read-file-contents"><a class="header" href="#read---read-file-contents"><code>read</code> - Read File Contents</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsRead, FsError, FileType};

impl FsRead for TutorialFs {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let path = Self::normalize_path(path);
        let inner = self.inner.read().unwrap();

        // Look up the node
        let node = inner.nodes.get(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        // Directories can't be read as files
        if node.file_type == FileType::Directory {
            return Err(FsError::IsADirectory { path });
        }

        Ok(node.content.clone())
    }
    // ...
}
<span class="boring">}</span></code></pre>
<p><strong>Key points:</strong></p>
<ul>
<li>Normalize the path first for consistent lookup</li>
<li>Return <code>FsError::NotFound</code> if the path doesn’t exist</li>
<li>Return <code>FsError::IsADirectory</code> if trying to read a directory</li>
</ul>
<h3 id="metadata---get-file-information"><a class="header" href="#metadata---get-file-information"><code>metadata</code> - Get File Information</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        let path = Self::normalize_path(path);
        let inner = self.inner.read().unwrap();

        let node = inner.nodes.get(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        Ok(node.to_metadata(&amp;path))
    }
<span class="boring">}</span></code></pre>
<p>The <code>Metadata</code> struct contains:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>path</code></td><td><code>PathBuf</code></td><td>The queried path</td></tr>
<tr><td><code>file_type</code></td><td><code>FileType</code></td><td>File, Directory, or Symlink</td></tr>
<tr><td><code>len</code></td><td><code>u64</code></td><td>Size in bytes</td></tr>
<tr><td><code>permissions</code></td><td><code>Permissions</code></td><td>Permission bits</td></tr>
<tr><td><code>created</code></td><td><code>Option&lt;SystemTime&gt;</code></td><td>Creation time</td></tr>
<tr><td><code>modified</code></td><td><code>Option&lt;SystemTime&gt;</code></td><td>Last modification</td></tr>
<tr><td><code>accessed</code></td><td><code>Option&lt;SystemTime&gt;</code></td><td>Last access</td></tr>
<tr><td><code>inode</code></td><td><code>Option&lt;u64&gt;</code></td><td>Inode number</td></tr>
<tr><td><code>uid</code></td><td><code>Option&lt;u32&gt;</code></td><td>Owner user ID</td></tr>
<tr><td><code>gid</code></td><td><code>Option&lt;u32&gt;</code></td><td>Owner group ID</td></tr>
<tr><td><code>nlink</code></td><td><code>Option&lt;u32&gt;</code></td><td>Hard link count</td></tr>
</tbody>
</table>
</div>
<h3 id="exists---check-path-existence"><a class="header" href="#exists---check-path-existence"><code>exists</code> - Check Path Existence</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn exists(&amp;self, path: &amp;Path) -&gt; bool {
        let path = Self::normalize_path(path);
        let inner = self.inner.read().unwrap();
        inner.nodes.contains_key(&amp;path)
    }
<span class="boring">}</span></code></pre>
<p><strong>Important:</strong> <code>exists</code> never fails. It returns <code>false</code> for any error condition.</p>
<h2 id="error-handling-guidelines"><a class="header" href="#error-handling-guidelines">Error Handling Guidelines</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Situation</th><th>Error to return</th></tr>
</thead>
<tbody>
<tr><td>Path doesn’t exist</td><td><code>FsError::NotFound { path }</code></td></tr>
<tr><td>Path is a directory when file expected</td><td><code>FsError::IsADirectory { path }</code></td></tr>
<tr><td>Permission denied</td><td><code>FsError::PermissionDenied { path }</code></td></tr>
</tbody>
</table>
</div>
<p>Always include the path in error context so callers know what failed.</p>
<h2 id="testing-your-implementation"><a class="header" href="#testing-your-implementation">Testing Your Implementation</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_read_existing_file() {
    let fs = TutorialFs::new();
    
    // Setup: Create a file (we'll implement write later)
    {
        let mut inner = fs.inner.write().unwrap();
        let inode = TutorialFs::alloc_inode(&amp;mut inner);
        let node = FsNode::new_file(b"Hello, World!".to_vec(), inode);
        inner.nodes.insert(PathBuf::from("/test.txt"), node);
    }
    
    // Test read
    let content = fs.read(Path::new("/test.txt")).unwrap();
    assert_eq!(content, b"Hello, World!");
}

#[test]
fn test_read_nonexistent_file() {
    let fs = TutorialFs::new();
    
    let result = fs.read(Path::new("/nonexistent.txt"));
    assert!(matches!(result, Err(FsError::NotFound { .. })));
}

#[test]
fn test_read_directory_fails() {
    let fs = TutorialFs::new();
    
    // Root directory exists
    let result = fs.read(Path::new("/"));
    assert!(matches!(result, Err(FsError::IsADirectory { .. })));
}

#[test]
fn test_exists() {
    let fs = TutorialFs::new();
    
    assert!(fs.exists(Path::new("/")));  // Root always exists
    assert!(!fs.exists(Path::new("/nonexistent")));
}
<span class="boring">}</span></code></pre>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p><code>FsRead</code> provides:</p>
<ul>
<li><code>read()</code> - Get file contents</li>
<li><code>metadata()</code> - Get file/directory information</li>
<li><code>exists()</code> - Quick existence check</li>
</ul>
<p>Next, we’ll implement <a href="#fswrite-writing-files">FsWrite →</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="fswrite-writing-files"><a class="header" href="#fswrite-writing-files">FsWrite: Writing Files</a></h1>
<p><code>FsWrite</code> provides write operations for files.</p>
<h2 id="the-trait-1"><a class="header" href="#the-trait-1">The Trait</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsWrite: Send + Sync {
    /// Write content to a file, creating it if it doesn't exist.
    fn write(&amp;self, path: &amp;Path, content: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;

    /// Remove a file.
    fn remove_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h2 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h2>
<h3 id="write---write-file-contents"><a class="header" href="#write---write-file-contents"><code>write</code> - Write File Contents</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsWrite, FsError, FileType};

impl FsWrite for TutorialFs {
    fn write(&amp;self, path: &amp;Path, content: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        let path = Self::normalize_path(path);
        let mut inner = self.inner.write().unwrap();

        // Check parent directory exists
        if let Some(parent) = path.parent() {
            let parent = Self::normalize_path(parent);
            match inner.nodes.get(&amp;parent) {
                None =&gt; {
                    return Err(FsError::NotFound { path: parent });
                }
                Some(node) if node.file_type != FileType::Directory =&gt; {
                    return Err(FsError::NotADirectory { path: parent });
                }
                _ =&gt; {}
            }
        }

        // Can't write to a directory
        if let Some(existing) = inner.nodes.get(&amp;path) {
            if existing.file_type == FileType::Directory {
                return Err(FsError::IsADirectory { path });
            }
        }

        // Create or update the file
        let inode = if let Some(existing) = inner.nodes.get(&amp;path) {
            existing.inode  // Reuse existing inode
        } else {
            Self::alloc_inode(&amp;mut inner)
        };

        let mut node = FsNode::new_file(content.to_vec(), inode);
        node.modified = SystemTime::now();

        inner.inode_to_path.insert(inode, path.clone());
        inner.nodes.insert(path, node);

        Ok(())
    }
    // ...
}
<span class="boring">}</span></code></pre>
<p><strong>Key points:</strong></p>
<ul>
<li>Verify parent directory exists before creating file</li>
<li>Reuse inode if file already exists (overwrite)</li>
<li>Update modification timestamp</li>
</ul>
<h3 id="remove_file---delete-a-file"><a class="header" href="#remove_file---delete-a-file"><code>remove_file</code> - Delete a File</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn remove_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = Self::normalize_path(path);
        let mut inner = self.inner.write().unwrap();

        let node = inner.nodes.get(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        // Can't remove directories with remove_file
        if node.file_type == FileType::Directory {
            return Err(FsError::IsADirectory { path });
        }

        let inode = node.inode;
        inner.nodes.remove(&amp;path);
        inner.inode_to_path.remove(&amp;inode);

        Ok(())
    }
<span class="boring">}</span></code></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Situation</th><th>Error</th></tr>
</thead>
<tbody>
<tr><td>Parent directory doesn’t exist</td><td><code>FsError::NotFound { path: parent }</code></td></tr>
<tr><td>Parent path is a file, not directory</td><td><code>FsError::NotADirectory { path: parent }</code></td></tr>
<tr><td>Target path is a directory</td><td><code>FsError::IsADirectory { path }</code></td></tr>
<tr><td>File to remove doesn’t exist</td><td><code>FsError::NotFound { path }</code></td></tr>
</tbody>
</table>
</div>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_write_creates_file() {
    let fs = TutorialFs::new();
    
    fs.write(Path::new("/hello.txt"), b"Hello!").unwrap();
    
    let content = fs.read(Path::new("/hello.txt")).unwrap();
    assert_eq!(content, b"Hello!");
}

#[test]
fn test_write_overwrites_existing() {
    let fs = TutorialFs::new();
    
    fs.write(Path::new("/file.txt"), b"First").unwrap();
    fs.write(Path::new("/file.txt"), b"Second").unwrap();
    
    let content = fs.read(Path::new("/file.txt")).unwrap();
    assert_eq!(content, b"Second");
}

#[test]
fn test_write_to_nonexistent_parent_fails() {
    let fs = TutorialFs::new();
    
    let result = fs.write(Path::new("/no/such/dir/file.txt"), b"data");
    assert!(matches!(result, Err(FsError::NotFound { .. })));
}

#[test]
fn test_remove_file() {
    let fs = TutorialFs::new();
    
    fs.write(Path::new("/temp.txt"), b"temp").unwrap();
    assert!(fs.exists(Path::new("/temp.txt")));
    
    fs.remove_file(Path::new("/temp.txt")).unwrap();
    assert!(!fs.exists(Path::new("/temp.txt")));
}
<span class="boring">}</span></code></pre>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p><code>FsWrite</code> provides:</p>
<ul>
<li><code>write()</code> - Create or overwrite file contents</li>
<li><code>remove_file()</code> - Delete a file</li>
</ul>
<p>Next, we’ll implement <a href="#fsdir-directory-operations">FsDir →</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="fsdir-directory-operations"><a class="header" href="#fsdir-directory-operations">FsDir: Directory Operations</a></h1>
<p><code>FsDir</code> provides directory operations: listing, creating, removing, and renaming.</p>
<h2 id="the-trait-2"><a class="header" href="#the-trait-2">The Trait</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsDir: Send + Sync {
    /// List directory contents.
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt;;

    /// Create a single directory.
    fn create_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;

    /// Create directory and all parent directories.
    fn create_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;

    /// Remove an empty directory.
    fn remove_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;

    /// Remove directory and all contents recursively.
    fn remove_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;

    /// Rename/move a file or directory.
    fn rename(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h2 id="the-readdiriter-type"><a class="header" href="#the-readdiriter-type">The ReadDirIter Type</a></h2>
<p><code>read_dir</code> returns a <code>ReadDirIter</code>, which is a boxed iterator over <code>Result&lt;DirEntry, FsError&gt;</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// DirEntry contains info about each directory entry
pub struct DirEntry {
    pub path: PathBuf,       // Full path
    pub name: String,        // Just the filename
    pub file_type: FileType, // File, Directory, or Symlink
    pub inode: Option&lt;u64&gt;,  // Inode if available
}

// ReadDirIter is an iterator
pub struct ReadDirIter(Box&lt;dyn Iterator&lt;Item = Result&lt;DirEntry, FsError&gt;&gt; + Send&gt;);
<span class="boring">}</span></code></pre>
<p>Create a <code>ReadDirIter</code> from a vector:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entries = vec![
    Ok(DirEntry { path: PathBuf::from("/foo"), name: "foo".into(), ... }),
    Ok(DirEntry { path: PathBuf::from("/bar"), name: "bar".into(), ... }),
];
ReadDirIter::from_vec(entries)
<span class="boring">}</span></code></pre>
<h2 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h2>
<h3 id="read_dir---list-directory-contents"><a class="header" href="#read_dir---list-directory-contents"><code>read_dir</code> - List Directory Contents</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsDir for TutorialFs {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt; {
        let path = Self::normalize_path(path);
        let inner = self.inner.read().unwrap();

        // Verify path exists and is a directory
        let node = inner.nodes.get(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        if node.file_type != FileType::Directory {
            return Err(FsError::NotADirectory { path });
        }

        // Collect direct children
        let mut entries = Vec::new();
        for (child_path, child_node) in &amp;inner.nodes {
            if let Some(parent) = child_path.parent() {
                if Self::normalize_path(parent) == path &amp;&amp; child_path != &amp;path {
                    let name = child_path
                        .file_name()
                        .map(|n| n.to_string_lossy().to_string())
                        .unwrap_or_default();

                    entries.push(Ok(DirEntry {
                        path: child_path.clone(),
                        name,
                        file_type: child_node.file_type,
                        inode: Some(child_node.inode),
                    }));
                }
            }
        }

        // Sort for consistent ordering
        entries.sort_by_key(|e| e.as_ref().map(|e| e.name.clone()).ok());

        Ok(ReadDirIter::from_vec(entries))
    }
    // ...
}
<span class="boring">}</span></code></pre>
<h3 id="create_dir---create-single-directory"><a class="header" href="#create_dir---create-single-directory"><code>create_dir</code> - Create Single Directory</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn create_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = Self::normalize_path(path);
        let mut inner = self.inner.write().unwrap();

        // Check if already exists
        if inner.nodes.contains_key(&amp;path) {
            return Err(FsError::AlreadyExists { path });
        }

        // Check parent exists and is a directory
        if let Some(parent) = path.parent() {
            let parent = Self::normalize_path(parent);
            match inner.nodes.get(&amp;parent) {
                None =&gt; return Err(FsError::NotFound { path: parent }),
                Some(node) if node.file_type != FileType::Directory =&gt; {
                    return Err(FsError::NotADirectory { path: parent });
                }
                _ =&gt; {}
            }
        }

        let inode = Self::alloc_inode(&amp;mut inner);
        let node = FsNode::new_directory(inode);
        inner.inode_to_path.insert(inode, path.clone());
        inner.nodes.insert(path, node);

        Ok(())
    }
<span class="boring">}</span></code></pre>
<h3 id="create_dir_all---create-directory-tree"><a class="header" href="#create_dir_all---create-directory-tree"><code>create_dir_all</code> - Create Directory Tree</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn create_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = Self::normalize_path(path);

        // Build list of directories to create (from root to leaf)
        let mut to_create = Vec::new();
        let mut current = path.clone();

        while current != Path::new("/") {
            if !self.exists(&amp;current) {
                to_create.push(current.clone());
            }
            match current.parent() {
                Some(parent) =&gt; current = parent.to_path_buf(),
                None =&gt; break,
            }
        }

        // Create from root towards leaf
        to_create.reverse();
        for dir in to_create {
            match self.create_dir(&amp;dir) {
                Ok(()) | Err(FsError::AlreadyExists { .. }) =&gt; {}
                Err(e) =&gt; return Err(e),
            }
        }

        Ok(())
    }
<span class="boring">}</span></code></pre>
<p><strong>Note:</strong> <code>create_dir_all</code> is idempotent—it succeeds even if the directory exists.</p>
<h3 id="remove_dir---remove-empty-directory"><a class="header" href="#remove_dir---remove-empty-directory"><code>remove_dir</code> - Remove Empty Directory</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn remove_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = Self::normalize_path(path);
        let mut inner = self.inner.write().unwrap();

        let node = inner.nodes.get(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        if node.file_type != FileType::Directory {
            return Err(FsError::NotADirectory { path });
        }

        // Check if directory is empty
        for other_path in inner.nodes.keys() {
            if let Some(parent) = other_path.parent() {
                if Self::normalize_path(parent) == path {
                    return Err(FsError::DirectoryNotEmpty { path });
                }
            }
        }

        let inode = node.inode;
        inner.nodes.remove(&amp;path);
        inner.inode_to_path.remove(&amp;inode);

        Ok(())
    }
<span class="boring">}</span></code></pre>
<h3 id="remove_dir_all---remove-recursively"><a class="header" href="#remove_dir_all---remove-recursively"><code>remove_dir_all</code> - Remove Recursively</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn remove_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = Self::normalize_path(path);
        let mut inner = self.inner.write().unwrap();

        // Verify it exists and is a directory
        let node = inner.nodes.get(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        if node.file_type != FileType::Directory {
            return Err(FsError::NotADirectory { path });
        }

        // Collect all paths to remove
        let to_remove: Vec&lt;PathBuf&gt; = inner.nodes.keys()
            .filter(|p| p.starts_with(&amp;path))
            .cloned()
            .collect();

        for p in to_remove {
            if let Some(node) = inner.nodes.remove(&amp;p) {
                inner.inode_to_path.remove(&amp;node.inode);
            }
        }

        Ok(())
    }
<span class="boring">}</span></code></pre>
<h3 id="rename---moverename"><a class="header" href="#rename---moverename"><code>rename</code> - Move/Rename</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn rename(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let from = Self::normalize_path(from);
        let to = Self::normalize_path(to);
        let mut inner = self.inner.write().unwrap();

        if !inner.nodes.contains_key(&amp;from) {
            return Err(FsError::NotFound { path: from });
        }

        if inner.nodes.contains_key(&amp;to) {
            return Err(FsError::AlreadyExists { path: to });
        }

        // Check destination parent exists
        if let Some(parent) = to.parent() {
            let parent = Self::normalize_path(parent);
            if !inner.nodes.contains_key(&amp;parent) {
                return Err(FsError::NotFound { path: parent });
            }
        }

        if let Some(node) = inner.nodes.remove(&amp;from) {
            inner.inode_to_path.insert(node.inode, to.clone());
            inner.nodes.insert(to, node);
        }

        Ok(())
    }
<span class="boring">}</span></code></pre>
<h2 id="testing-1"><a class="header" href="#testing-1">Testing</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_create_and_list_dir() {
    let fs = TutorialFs::new();
    
    fs.create_dir(Path::new("/subdir")).unwrap();
    fs.write(Path::new("/subdir/file.txt"), b"content").unwrap();
    
    let entries: Vec&lt;_&gt; = fs.read_dir(Path::new("/subdir"))
        .unwrap()
        .collect();
    
    assert_eq!(entries.len(), 1);
    assert_eq!(entries[0].as_ref().unwrap().name, "file.txt");
}

#[test]
fn test_create_dir_all() {
    let fs = TutorialFs::new();
    
    fs.create_dir_all(Path::new("/a/b/c/d")).unwrap();
    
    assert!(fs.exists(Path::new("/a")));
    assert!(fs.exists(Path::new("/a/b")));
    assert!(fs.exists(Path::new("/a/b/c")));
    assert!(fs.exists(Path::new("/a/b/c/d")));
}

#[test]
fn test_remove_nonempty_dir_fails() {
    let fs = TutorialFs::new();
    
    fs.create_dir(Path::new("/dir")).unwrap();
    fs.write(Path::new("/dir/file.txt"), b"data").unwrap();
    
    let result = fs.remove_dir(Path::new("/dir"));
    assert!(matches!(result, Err(FsError::DirectoryNotEmpty { .. })));
}
<span class="boring">}</span></code></pre>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p><code>FsDir</code> provides:</p>
<ul>
<li><code>read_dir()</code> - List directory entries</li>
<li><code>create_dir()</code> / <code>create_dir_all()</code> - Create directories</li>
<li><code>remove_dir()</code> / <code>remove_dir_all()</code> - Remove directories</li>
<li><code>rename()</code> - Move or rename entries</li>
</ul>
<p>Next: <a href="#the-fs-trait">The Fs Trait →</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-fs-trait"><a class="header" href="#the-fs-trait">The Fs Trait</a></h1>
<p><code>Fs</code> is the first composite trait. It combines <code>FsRead</code>, <code>FsWrite</code>, and <code>FsDir</code> into a single bound.</p>
<h2 id="automatic-implementation-1"><a class="header" href="#automatic-implementation-1">Automatic Implementation</a></h2>
<p>Here’s the magic: <strong>you don’t implement <code>Fs</code> directly</strong>. It’s automatically provided:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In anyfs-backend (simplified)
pub trait Fs: FsRead + FsWrite + FsDir + Send + Sync {}

// Blanket implementation
impl&lt;T&gt; Fs for T where T: FsRead + FsWrite + FsDir + Send + Sync {}
<span class="boring">}</span></code></pre>
<p>If your type implements <code>FsRead + FsWrite + FsDir</code> and is <code>Send + Sync</code>, it automatically implements <code>Fs</code>.</p>
<h2 id="verify-your-implementation"><a class="header" href="#verify-your-implementation">Verify Your Implementation</a></h2>
<p>After implementing the three component traits, verify <code>Fs</code> works:</p>
<pre class="playground"><code class="language-rust">// Compile-time verification
fn use_fs&lt;B: Fs&gt;(_: &amp;B) {}

fn main() {
    let fs = TutorialFs::new();
    use_fs(&amp;fs);  // ✅ Compiles! TutorialFs implements Fs
}</code></pre>
<p>You can also verify <code>Send + Sync</code> at compile time:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const _: () = {
    const fn assert_send_sync&lt;T: Send + Sync&gt;() {}
    assert_send_sync::&lt;TutorialFs&gt;();
};
<span class="boring">}</span></code></pre>
<h2 id="using-the-fs-bound"><a class="header" href="#using-the-fs-bound">Using the Fs Bound</a></h2>
<p>Now you can write generic functions that work with any filesystem:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{Fs, FsError};
use std::path::Path;

/// Copy a file from src to dst.
fn copy_file&lt;B: Fs&gt;(fs: &amp;B, src: &amp;Path, dst: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
    let content = fs.read(src)?;
    fs.write(dst, &amp;content)
}

/// Count files in a directory (non-recursive).
fn count_files&lt;B: Fs&gt;(fs: &amp;B, dir: &amp;Path) -&gt; Result&lt;usize, FsError&gt; {
    let mut count = 0;
    for entry in fs.read_dir(dir)? {
        let entry = entry?;
        if entry.file_type == FileType::File {
            count += 1;
        }
    }
    Ok(count)
}

/// Check if a path is a file.
fn is_file&lt;B: Fs&gt;(fs: &amp;B, path: &amp;Path) -&gt; bool {
    fs.metadata(path)
        .map(|m| m.file_type == FileType::File)
        .unwrap_or(false)
}
<span class="boring">}</span></code></pre>
<h2 id="what-fs-provides"><a class="header" href="#what-fs-provides">What Fs Provides</a></h2>
<p>At this point, your backend supports:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Method</th></tr>
</thead>
<tbody>
<tr><td>Read file contents</td><td><code>read()</code></td></tr>
<tr><td>Get metadata</td><td><code>metadata()</code></td></tr>
<tr><td>Check existence</td><td><code>exists()</code></td></tr>
<tr><td>Write file</td><td><code>write()</code></td></tr>
<tr><td>Delete file</td><td><code>remove_file()</code></td></tr>
<tr><td>List directory</td><td><code>read_dir()</code></td></tr>
<tr><td>Create directory</td><td><code>create_dir()</code> / <code>create_dir_all()</code></td></tr>
<tr><td>Remove directory</td><td><code>remove_dir()</code> / <code>remove_dir_all()</code></td></tr>
<tr><td>Rename/move</td><td><code>rename()</code></td></tr>
</tbody>
</table>
</div>
<p>This is sufficient for many use cases!</p>
<h2 id="whats-missing"><a class="header" href="#whats-missing">What’s Missing?</a></h2>
<p><code>Fs</code> doesn’t include:</p>
<ul>
<li>Symlinks (<code>FsLink</code>)</li>
<li>Permissions (<code>FsPermissions</code>)</li>
<li>Sync/flush (<code>FsSync</code>)</li>
<li>Disk stats (<code>FsStats</code>)</li>
<li>Inode operations (<code>FsInode</code>)</li>
<li>File handles (<code>FsHandles</code>)</li>
<li>Locking (<code>FsLock</code>)</li>
</ul>
<p>The remaining tutorials add these features.</p>
<h2 id="integration-test"><a class="header" href="#integration-test">Integration Test</a></h2>
<p>Here’s a complete test exercising <code>Fs</code>:</p>
<pre class="playground"><code class="language-rust">#[test]
fn test_fs_workflow() {
    let fs = TutorialFs::new();

    // Create a project structure
    fs.create_dir_all(Path::new("/project/src")).unwrap();
    
    // Write some files
    fs.write(Path::new("/project/README.md"), b"# My Project").unwrap();
    fs.write(Path::new("/project/src/main.rs"), b"fn main() {}").unwrap();
    
    // Verify structure
    assert!(fs.exists(Path::new("/project")));
    assert!(fs.exists(Path::new("/project/src")));
    assert!(fs.exists(Path::new("/project/README.md")));
    
    // Read back
    let readme = fs.read(Path::new("/project/README.md")).unwrap();
    assert_eq!(readme, b"# My Project");
    
    // List directory
    let entries: Vec&lt;_&gt; = fs.read_dir(Path::new("/project"))
        .unwrap()
        .filter_map(|e| e.ok())
        .collect();
    assert_eq!(entries.len(), 2);  // README.md and src/
    
    // Rename
    fs.rename(
        Path::new("/project/README.md"),
        Path::new("/project/README.txt"),
    ).unwrap();
    assert!(!fs.exists(Path::new("/project/README.md")));
    assert!(fs.exists(Path::new("/project/README.txt")));
    
    // Clean up
    fs.remove_dir_all(Path::new("/project")).unwrap();
    assert!(!fs.exists(Path::new("/project")));
}</code></pre>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<ul>
<li><code>Fs = FsRead + FsWrite + FsDir + Send + Sync</code></li>
<li><strong>Automatically implemented</strong> via blanket impl</li>
<li>Provides basic file operations</li>
<li>Sufficient for simple use cases</li>
</ul>
<p>Next: <a href="#fslink-symlinks">FsLink: Symlinks →</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="fslink-symlinks"><a class="header" href="#fslink-symlinks">FsLink: Symlinks</a></h1>
<p><code>FsLink</code> adds symbolic and hard link support to your backend.</p>
<h2 id="the-trait-3"><a class="header" href="#the-trait-3">The Trait</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsLink: Send + Sync {
    /// Create a symbolic link.
    fn symlink(&amp;self, target: &amp;Path, link: &amp;Path) -&gt; Result&lt;(), FsError&gt;;

    /// Read the target of a symbolic link.
    fn read_link(&amp;self, path: &amp;Path) -&gt; Result&lt;PathBuf, FsError&gt;;

    /// Create a hard link.
    fn hard_link(&amp;self, target: &amp;Path, link: &amp;Path) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h2 id="understanding-symlinks-vs-hard-links"><a class="header" href="#understanding-symlinks-vs-hard-links">Understanding Symlinks vs Hard Links</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Symlink</th><th>Hard Link</th></tr>
</thead>
<tbody>
<tr><td>What it stores</td><td>Path to target</td><td>Same inode as target</td></tr>
<tr><td>Target can be…</td><td>Anything (even nonexistent)</td><td>Must exist and be a file</td></tr>
<tr><td>Cross-filesystem</td><td>Yes</td><td>No</td></tr>
<tr><td>If target deleted</td><td>Becomes broken</td><td>File still accessible</td></tr>
</tbody>
</table>
</div>
<h2 id="implementation-3"><a class="header" href="#implementation-3">Implementation</a></h2>
<h3 id="symlink---create-symbolic-link"><a class="header" href="#symlink---create-symbolic-link"><code>symlink</code> - Create Symbolic Link</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsLink for TutorialFs {
    fn symlink(&amp;self, target: &amp;Path, link: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let link = Self::normalize_path(link);
        let mut inner = self.inner.write().unwrap();

        // Check if link path already exists
        if inner.nodes.contains_key(&amp;link) {
            return Err(FsError::AlreadyExists { path: link });
        }

        // Check parent directory exists
        if let Some(parent) = link.parent() {
            let parent = Self::normalize_path(parent);
            if !inner.nodes.contains_key(&amp;parent) {
                return Err(FsError::NotFound { path: parent });
            }
        }

        // Create the symlink node
        // Note: target is stored as-is, not normalized
        let inode = Self::alloc_inode(&amp;mut inner);
        let node = FsNode::new_symlink(target.to_path_buf(), inode);
        inner.inode_to_path.insert(inode, link.clone());
        inner.nodes.insert(link, node);

        Ok(())
    }
    // ...
}
<span class="boring">}</span></code></pre>
<p><strong>Key points:</strong></p>
<ul>
<li>The <code>target</code> path is stored as-is (can be relative or absolute)</li>
<li>The target doesn’t need to exist</li>
<li>The <code>link</code> path must not already exist</li>
</ul>
<h3 id="read_link---get-symlink-target"><a class="header" href="#read_link---get-symlink-target"><code>read_link</code> - Get Symlink Target</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn read_link(&amp;self, path: &amp;Path) -&gt; Result&lt;PathBuf, FsError&gt; {
        let path = Self::normalize_path(path);
        let inner = self.inner.read().unwrap();

        let node = inner.nodes.get(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        match &amp;node.symlink_target {
            Some(target) =&gt; Ok(target.clone()),
            None =&gt; Err(FsError::InvalidData {
                details: format!("{} is not a symbolic link", path.display()),
            }),
        }
    }
<span class="boring">}</span></code></pre>
<h3 id="hard_link---create-hard-link"><a class="header" href="#hard_link---create-hard-link"><code>hard_link</code> - Create Hard Link</a></h3>
<p>Hard links are more complex because they share inodes. For simplicity, you can return <code>Unsupported</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn hard_link(&amp;self, _target: &amp;Path, _link: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::Unsupported {
            operation: "hard_link".to_string(),
        })
    }
<span class="boring">}</span></code></pre>
<p>Or implement properly by having multiple paths point to the same inode:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn hard_link(&amp;self, target: &amp;Path, link: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let target = Self::normalize_path(target);
        let link = Self::normalize_path(link);
        let mut inner = self.inner.write().unwrap();

        // Target must exist and be a file
        let target_node = inner.nodes.get(&amp;target)
            .ok_or_else(|| FsError::NotFound { path: target.clone() })?;
        
        if target_node.file_type != FileType::File {
            return Err(FsError::InvalidData {
                details: "hard links can only target files".to_string(),
            });
        }

        // Link must not exist
        if inner.nodes.contains_key(&amp;link) {
            return Err(FsError::AlreadyExists { path: link });
        }

        // Clone the node (same content, same inode)
        let mut link_node = target_node.clone();
        // Note: In a real impl, you'd track nlink count
        
        inner.nodes.insert(link.clone(), link_node);
        // Don't add to inode_to_path - inode already maps to target

        Ok(())
    }
<span class="boring">}</span></code></pre>
<h2 id="symlink-resolution"><a class="header" href="#symlink-resolution">Symlink Resolution</a></h2>
<p>When reading through a symlink, you may need to resolve it:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Resolve a path, following symlinks.
fn resolve_path&lt;B: Fs + FsLink&gt;(fs: &amp;B, path: &amp;Path) -&gt; Result&lt;PathBuf, FsError&gt; {
    let mut current = path.to_path_buf();
    let mut seen = std::collections::HashSet::new();

    loop {
        // Prevent infinite loops
        if !seen.insert(current.clone()) {
            return Err(FsError::InvalidData {
                details: "symlink loop detected".to_string(),
            });
        }

        match fs.metadata(&amp;current) {
            Ok(meta) if meta.file_type == FileType::Symlink =&gt; {
                let target = fs.read_link(&amp;current)?;
                current = if target.is_absolute() {
                    target
                } else {
                    current.parent().unwrap_or(Path::new("/")).join(target)
                };
            }
            Ok(_) =&gt; return Ok(current),
            Err(e) =&gt; return Err(e),
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="testing-2"><a class="header" href="#testing-2">Testing</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_symlink_creation() {
    let fs = TutorialFs::new();
    
    fs.write(Path::new("/original.txt"), b"content").unwrap();
    fs.symlink(Path::new("/original.txt"), Path::new("/link.txt")).unwrap();
    
    // Check metadata shows it's a symlink
    let meta = fs.metadata(Path::new("/link.txt")).unwrap();
    assert_eq!(meta.file_type, FileType::Symlink);
    
    // Read the link target
    let target = fs.read_link(Path::new("/link.txt")).unwrap();
    assert_eq!(target, Path::new("/original.txt"));
}

#[test]
fn test_symlink_to_nonexistent() {
    let fs = TutorialFs::new();
    
    // This should succeed - symlinks can point to nonexistent targets
    fs.symlink(Path::new("/nonexistent"), Path::new("/broken-link")).unwrap();
    
    let target = fs.read_link(Path::new("/broken-link")).unwrap();
    assert_eq!(target, Path::new("/nonexistent"));
}

#[test]
fn test_read_link_on_regular_file_fails() {
    let fs = TutorialFs::new();
    
    fs.write(Path::new("/file.txt"), b"data").unwrap();
    
    let result = fs.read_link(Path::new("/file.txt"));
    assert!(matches!(result, Err(FsError::InvalidData { .. })));
}
<span class="boring">}</span></code></pre>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p><code>FsLink</code> provides:</p>
<ul>
<li><code>symlink()</code> - Create symbolic links</li>
<li><code>read_link()</code> - Read symlink target</li>
<li><code>hard_link()</code> - Create hard links (optional)</li>
</ul>
<p>Next: <a href="#fsfull-complete-filesystem">FsFull: Complete Filesystem →</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="fsfull-complete-filesystem"><a class="header" href="#fsfull-complete-filesystem">FsFull: Complete Filesystem</a></h1>
<p><code>FsFull</code> adds permissions, sync, and stats to reach “complete” filesystem semantics.</p>
<h2 id="the-trait-4"><a class="header" href="#the-trait-4">The Trait</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FsFull = Fs + FsLink + FsPermissions + FsSync + FsStats
pub trait FsFull: Fs + FsLink + FsPermissions + FsSync + FsStats {}
<span class="boring">}</span></code></pre>
<p>Like <code>Fs</code>, it’s <strong>automatically implemented</strong> via blanket impl.</p>
<h2 id="component-traits"><a class="header" href="#component-traits">Component Traits</a></h2>
<h3 id="fspermissions"><a class="header" href="#fspermissions">FsPermissions</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsPermissions: Send + Sync {
    /// Set file/directory permissions.
    fn set_permissions(&amp;self, path: &amp;Path, permissions: Permissions) -&gt; Result&lt;(), FsError&gt;;

    /// Set owner UID and/or GID.
    fn set_owner(&amp;self, path: &amp;Path, uid: Option&lt;u32&gt;, gid: Option&lt;u32&gt;) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p>Implementation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsPermissions for TutorialFs {
    fn set_permissions(&amp;self, path: &amp;Path, permissions: Permissions) -&gt; Result&lt;(), FsError&gt; {
        let path = Self::normalize_path(path);
        let mut inner = self.inner.write().unwrap();

        let node = inner.nodes.get_mut(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        node.permissions = permissions;
        node.modified = SystemTime::now();

        Ok(())
    }

    fn set_owner(&amp;self, path: &amp;Path, uid: Option&lt;u32&gt;, gid: Option&lt;u32&gt;) -&gt; Result&lt;(), FsError&gt; {
        let path = Self::normalize_path(path);
        let inner = self.inner.read().unwrap();

        // Verify path exists
        if !inner.nodes.contains_key(&amp;path) {
            return Err(FsError::NotFound { path });
        }

        // In-memory fs: we don't actually store uid/gid changes
        // A real implementation would update the node
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h3 id="fssync"><a class="header" href="#fssync">FsSync</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsSync: Send + Sync {
    /// Flush pending writes for a specific file.
    fn sync(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt;;

    /// Flush all pending writes.
    fn sync_all(&amp;self) -&gt; Result&lt;(), FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p>Implementation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsSync for TutorialFs {
    fn sync(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        let path = Self::normalize_path(path);
        let inner = self.inner.read().unwrap();

        // Verify file exists
        if !inner.nodes.contains_key(&amp;path) {
            return Err(FsError::NotFound { path });
        }

        // In-memory: nothing to sync
        Ok(())
    }

    fn sync_all(&amp;self) -&gt; Result&lt;(), FsError&gt; {
        // In-memory: nothing to sync
        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<p>For a real disk-backed filesystem, you’d call <code>fsync()</code> or equivalent.</p>
<h3 id="fsstats"><a class="header" href="#fsstats">FsStats</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsStats: Send + Sync {
    /// Get filesystem statistics.
    fn statfs(&amp;self) -&gt; Result&lt;StatFs, FsError&gt;;
}

pub struct StatFs {
    pub total_bytes: u64,
    pub available_bytes: u64,
    pub used_bytes: u64,
    pub total_inodes: Option&lt;u64&gt;,
    pub available_inodes: Option&lt;u64&gt;,
    pub used_inodes: Option&lt;u64&gt;,
    pub block_size: Option&lt;u64&gt;,
}
<span class="boring">}</span></code></pre>
<p>Implementation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsStats for TutorialFs {
    fn statfs(&amp;self) -&gt; Result&lt;StatFs, FsError&gt; {
        let inner = self.inner.read().unwrap();

        // Calculate used space
        let used_bytes: u64 = inner.nodes.values()
            .map(|n| n.content.len() as u64)
            .sum();

        let used_inodes = inner.nodes.len() as u64;

        Ok(StatFs {
            total_bytes: inner.total_size,
            available_bytes: inner.total_size.saturating_sub(used_bytes),
            used_bytes,
            total_inodes: Some(1_000_000),
            available_inodes: Some(1_000_000 - used_inodes),
            used_inodes: Some(used_inodes),
            block_size: Some(4096),
        })
    }
}
<span class="boring">}</span></code></pre>
<h2 id="verify-fsfull"><a class="header" href="#verify-fsfull">Verify FsFull</a></h2>
<p>After implementing all component traits:</p>
<pre class="playground"><code class="language-rust">fn use_fs_full&lt;B: FsFull&gt;(_: &amp;B) {}

fn main() {
    let fs = TutorialFs::new();
    use_fs_full(&amp;fs);  // ✅ Compiles!
}</code></pre>
<h2 id="using-fsfull"><a class="header" href="#using-fsfull">Using FsFull</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsFull, FsError, Permissions};

/// Make a file read-only.
fn make_readonly&lt;B: FsFull&gt;(fs: &amp;B, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
    fs.set_permissions(path, Permissions::from_mode(0o444))
}

/// Get disk usage percentage.
fn disk_usage&lt;B: FsFull&gt;(fs: &amp;B) -&gt; Result&lt;f64, FsError&gt; {
    let stats = fs.statfs()?;
    Ok((stats.used_bytes as f64 / stats.total_bytes as f64) * 100.0)
}

/// Write and flush immediately.
fn write_sync&lt;B: FsFull&gt;(fs: &amp;B, path: &amp;Path, data: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
    fs.write(path, data)?;
    fs.sync(path)
}
<span class="boring">}</span></code></pre>
<h2 id="testing-3"><a class="header" href="#testing-3">Testing</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_set_permissions() {
    let fs = TutorialFs::new();
    
    fs.write(Path::new("/file.txt"), b"data").unwrap();
    fs.set_permissions(Path::new("/file.txt"), Permissions::from_mode(0o600)).unwrap();
    
    let meta = fs.metadata(Path::new("/file.txt")).unwrap();
    assert_eq!(meta.permissions.mode(), 0o600);
}

#[test]
fn test_statfs() {
    let fs = TutorialFs::new();
    
    // Write some data
    fs.write(Path::new("/a.txt"), b"Hello").unwrap();
    fs.write(Path::new("/b.txt"), b"World!").unwrap();
    
    let stats = fs.statfs().unwrap();
    assert!(stats.used_bytes &gt;= 11);  // At least "Hello" + "World!"
    assert!(stats.available_bytes &lt; stats.total_bytes);
}
<span class="boring">}</span></code></pre>
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<p><code>FsFull = Fs + FsLink + FsPermissions + FsSync + FsStats</code></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Trait</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>FsPermissions</code></td><td>Set mode and ownership</td></tr>
<tr><td><code>FsSync</code></td><td>Flush data to storage</td></tr>
<tr><td><code>FsStats</code></td><td>Disk space information</td></tr>
</tbody>
</table>
</div>
<p>This is suitable for most real-world applications.</p>
<p>Next: <a href="#fsinode-fuse-support">FsInode: FUSE Support →</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="fsinode-fuse-support"><a class="header" href="#fsinode-fuse-support">FsInode: FUSE Support</a></h1>
<p><code>FsInode</code> provides inode-based operations, essential for FUSE (Filesystem in Userspace) implementations.</p>
<h2 id="why-inodes"><a class="header" href="#why-inodes">Why Inodes?</a></h2>
<p>FUSE operates on <strong>inodes</strong> rather than paths:</p>
<pre><code>Path-based:  read("/home/user/file.txt")
Inode-based: read(inode=12345, offset=0, len=100)
</code></pre>
<p>Benefits:</p>
<ul>
<li><strong>Efficiency</strong>: Inode lookup is O(1), path resolution is O(n)</li>
<li><strong>Handles edge cases</strong>: Deleted-but-open files, renamed files</li>
<li><strong>FUSE requirement</strong>: FUSE kernel module uses inodes</li>
</ul>
<h2 id="the-trait-5"><a class="header" href="#the-trait-5">The Trait</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsInode: Send + Sync {
    /// Convert a path to its inode number.
    fn path_to_inode(&amp;self, path: &amp;Path) -&gt; Result&lt;u64, FsError&gt;;

    /// Convert an inode to its path.
    fn inode_to_path(&amp;self, inode: u64) -&gt; Result&lt;PathBuf, FsError&gt;;

    /// Get metadata by inode.
    fn metadata_by_inode(&amp;self, inode: u64) -&gt; Result&lt;Metadata, FsError&gt;;

    /// Look up child by name within a parent directory.
    fn lookup(&amp;self, parent_inode: u64, name: &amp;str) -&gt; Result&lt;u64, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h2 id="the-root_inode-constant"><a class="header" href="#the-root_inode-constant">The ROOT_INODE Constant</a></h2>
<p>Root directory always has inode 1:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::ROOT_INODE;

assert_eq!(ROOT_INODE, 1);
<span class="boring">}</span></code></pre>
<h2 id="implementation-4"><a class="header" href="#implementation-4">Implementation</a></h2>
<h3 id="path_to_inode"><a class="header" href="#path_to_inode"><code>path_to_inode</code></a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsInode for TutorialFs {
    fn path_to_inode(&amp;self, path: &amp;Path) -&gt; Result&lt;u64, FsError&gt; {
        let path = Self::normalize_path(path);
        let inner = self.inner.read().unwrap();

        let node = inner.nodes.get(&amp;path)
            .ok_or_else(|| FsError::NotFound { path: path.clone() })?;

        Ok(node.inode)
    }
    // ...
}
<span class="boring">}</span></code></pre>
<h3 id="inode_to_path"><a class="header" href="#inode_to_path"><code>inode_to_path</code></a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn inode_to_path(&amp;self, inode: u64) -&gt; Result&lt;PathBuf, FsError&gt; {
        let inner = self.inner.read().unwrap();

        inner.inode_to_path.get(&amp;inode)
            .cloned()
            .ok_or(FsError::InodeNotFound { inode })
    }
<span class="boring">}</span></code></pre>
<p>Note the special error type <code>FsError::InodeNotFound</code>.</p>
<h3 id="metadata_by_inode"><a class="header" href="#metadata_by_inode"><code>metadata_by_inode</code></a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn metadata_by_inode(&amp;self, inode: u64) -&gt; Result&lt;Metadata, FsError&gt; {
        let inner = self.inner.read().unwrap();

        let path = inner.inode_to_path.get(&amp;inode)
            .ok_or(FsError::InodeNotFound { inode })?;

        let node = inner.nodes.get(path)
            .ok_or(FsError::InodeNotFound { inode })?;

        Ok(node.to_metadata(path))
    }
<span class="boring">}</span></code></pre>
<h3 id="lookup---the-key-fuse-operation"><a class="header" href="#lookup---the-key-fuse-operation"><code>lookup</code> - The Key FUSE Operation</a></h3>
<p>This is how FUSE navigates directories:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn lookup(&amp;self, parent_inode: u64, name: &amp;str) -&gt; Result&lt;u64, FsError&gt; {
        let inner = self.inner.read().unwrap();

        // Get parent path
        let parent_path = inner.inode_to_path.get(&amp;parent_inode)
            .ok_or(FsError::InodeNotFound { inode: parent_inode })?;

        // Build child path
        let child_path = parent_path.join(name);

        // Look up child
        let child_node = inner.nodes.get(&amp;child_path)
            .ok_or_else(|| FsError::NotFound { path: child_path })?;

        Ok(child_node.inode)
    }
<span class="boring">}</span></code></pre>
<h2 id="how-fuse-uses-this"><a class="header" href="#how-fuse-uses-this">How FUSE Uses This</a></h2>
<p>When a user accesses <code>/home/user/file.txt</code>, FUSE:</p>
<ol>
<li>Starts at ROOT_INODE (1)</li>
<li>Calls <code>lookup(1, "home")</code> → inode 2</li>
<li>Calls <code>lookup(2, "user")</code> → inode 5</li>
<li>Calls <code>lookup(5, "file.txt")</code> → inode 12</li>
<li>Calls <code>metadata_by_inode(12)</code> → file metadata</li>
</ol>
<h2 id="fsfuse-trait"><a class="header" href="#fsfuse-trait">FsFuse Trait</a></h2>
<p><code>FsFuse</code> combines everything:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsFuse: FsFull + FsInode {}
<span class="boring">}</span></code></pre>
<p>It’s automatically implemented:</p>
<pre class="playground"><code class="language-rust">fn use_fs_fuse&lt;B: FsFuse&gt;(_: &amp;B) {}

fn main() {
    let fs = TutorialFs::new();
    use_fs_fuse(&amp;fs);  // ✅ Works!
}</code></pre>
<h2 id="testing-4"><a class="header" href="#testing-4">Testing</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_path_to_inode() {
    let fs = TutorialFs::new();
    
    // Root is always inode 1
    let root_inode = fs.path_to_inode(Path::new("/")).unwrap();
    assert_eq!(root_inode, ROOT_INODE);
}

#[test]
fn test_inode_roundtrip() {
    let fs = TutorialFs::new();
    
    fs.create_dir(Path::new("/mydir")).unwrap();
    
    let inode = fs.path_to_inode(Path::new("/mydir")).unwrap();
    let path = fs.inode_to_path(inode).unwrap();
    
    assert_eq!(path, Path::new("/mydir"));
}

#[test]
fn test_lookup() {
    let fs = TutorialFs::new();
    
    fs.create_dir(Path::new("/parent")).unwrap();
    fs.write(Path::new("/parent/child.txt"), b"data").unwrap();
    
    let parent_inode = fs.path_to_inode(Path::new("/parent")).unwrap();
    let child_inode = fs.lookup(parent_inode, "child.txt").unwrap();
    
    let child_meta = fs.metadata_by_inode(child_inode).unwrap();
    assert_eq!(child_meta.file_type, FileType::File);
}

#[test]
fn test_lookup_from_root() {
    let fs = TutorialFs::new();
    
    fs.create_dir(Path::new("/documents")).unwrap();
    
    let docs_inode = fs.lookup(ROOT_INODE, "documents").unwrap();
    assert!(docs_inode &gt; ROOT_INODE);  // Should be a new inode
}

#[test]
fn test_inode_not_found() {
    let fs = TutorialFs::new();
    
    let result = fs.inode_to_path(99999);
    assert!(matches!(result, Err(FsError::InodeNotFound { inode: 99999 })));
}
<span class="boring">}</span></code></pre>
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<p><code>FsInode</code> provides inode-based access:</p>
<ul>
<li><code>path_to_inode()</code> / <code>inode_to_path()</code> - Convert between paths and inodes</li>
<li><code>metadata_by_inode()</code> - Get metadata by inode</li>
<li><code>lookup()</code> - Find child in directory by name</li>
</ul>
<p><code>FsFuse = FsFull + FsInode</code> - Ready for FUSE implementation.</p>
<p>Next: <a href="#fsposix-full-posix-semantics">FsPosix: Full POSIX →</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="fsposix-full-posix-semantics"><a class="header" href="#fsposix-full-posix-semantics">FsPosix: Full POSIX Semantics</a></h1>
<p><code>FsPosix</code> is the final layer, adding file handles, locking, and extended attributes for complete POSIX semantics.</p>
<h2 id="the-trait-6"><a class="header" href="#the-trait-6">The Trait</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsPosix: FsFuse + FsHandles + FsLock + FsXattr {}
<span class="boring">}</span></code></pre>
<h2 id="component-traits-1"><a class="header" href="#component-traits-1">Component Traits</a></h2>
<h3 id="fshandles---file-handle-operations"><a class="header" href="#fshandles---file-handle-operations">FsHandles - File Handle Operations</a></h3>
<p>Instead of reading/writing entire files, handles allow:</p>
<ul>
<li>Opening a file once, performing many operations</li>
<li>Reading/writing at specific offsets</li>
<li>Keeping files open across operations</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsHandles: Send + Sync {
    /// Open a file and return a handle.
    fn open(&amp;self, path: &amp;Path, flags: OpenFlags) -&gt; Result&lt;Handle, FsError&gt;;

    /// Close a file handle.
    fn close(&amp;self, handle: Handle) -&gt; Result&lt;(), FsError&gt;;

    /// Read from a file at a specific offset.
    fn read_at(&amp;self, handle: Handle, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;

    /// Write to a file at a specific offset.
    fn write_at(&amp;self, handle: Handle, offset: u64, data: &amp;[u8]) -&gt; Result&lt;usize, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<h4 id="openflags"><a class="header" href="#openflags">OpenFlags</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>bitflags! {
    pub struct OpenFlags: u32 {
        const READ = 0b0001;
        const WRITE = 0b0010;
        const CREATE = 0b0100;
        const TRUNCATE = 0b1000;
    }
}
<span class="boring">}</span></code></pre>
<h4 id="implementation-5"><a class="header" href="#implementation-5">Implementation</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsHandles for TutorialFs {
    fn open(&amp;self, path: &amp;Path, flags: OpenFlags) -&gt; Result&lt;Handle, FsError&gt; {
        let path = Self::normalize_path(path);
        let mut inner = self.inner.write().unwrap();

        let exists = inner.nodes.contains_key(&amp;path);

        // Handle creation
        if flags.contains(OpenFlags::CREATE) &amp;&amp; !exists {
            let inode = Self::alloc_inode(&amp;mut inner);
            let node = FsNode::new_file(Vec::new(), inode);
            inner.inode_to_path.insert(inode, path.clone());
            inner.nodes.insert(path.clone(), node);
        } else if !exists {
            return Err(FsError::NotFound { path });
        }

        // Truncate if requested
        if flags.contains(OpenFlags::TRUNCATE) {
            if let Some(node) = inner.nodes.get_mut(&amp;path) {
                node.content.clear();
            }
        }

        // Allocate handle
        let handle = Self::alloc_handle(&amp;mut inner);
        inner.handles.insert(handle, HandleState {
            path,
            flags,
            locked: None,
        });

        Ok(handle)
    }

    fn close(&amp;self, handle: Handle) -&gt; Result&lt;(), FsError&gt; {
        let mut inner = self.inner.write().unwrap();
        
        inner.handles.remove(&amp;handle)
            .ok_or(FsError::InvalidHandle { handle })?;
        
        Ok(())
    }

    fn read_at(&amp;self, handle: Handle, offset: u64, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let inner = self.inner.read().unwrap();

        let state = inner.handles.get(&amp;handle)
            .ok_or(FsError::InvalidHandle { handle })?;

        // Check read permission
        if !state.flags.contains(OpenFlags::READ) {
            return Err(FsError::PermissionDenied { path: state.path.clone() });
        }

        let node = inner.nodes.get(&amp;state.path)
            .ok_or_else(|| FsError::NotFound { path: state.path.clone() })?;

        let start = offset as usize;
        if start &gt;= node.content.len() {
            return Ok(Vec::new());  // EOF
        }

        let end = (start + len).min(node.content.len());
        Ok(node.content[start..end].to_vec())
    }

    fn write_at(&amp;self, handle: Handle, offset: u64, data: &amp;[u8]) -&gt; Result&lt;usize, FsError&gt; {
        let mut inner = self.inner.write().unwrap();

        // Get path from handle
        let path = {
            let state = inner.handles.get(&amp;handle)
                .ok_or(FsError::InvalidHandle { handle })?;

            if !state.flags.contains(OpenFlags::WRITE) {
                return Err(FsError::PermissionDenied { path: state.path.clone() });
            }
            state.path.clone()
        };

        let node = inner.nodes.get_mut(&amp;path)
            .ok_or_else(|| FsError::NotFound { path })?;

        let start = offset as usize;

        // Extend file if necessary
        if start + data.len() &gt; node.content.len() {
            node.content.resize(start + data.len(), 0);
        }

        node.content[start..start + data.len()].copy_from_slice(data);
        node.modified = SystemTime::now();

        Ok(data.len())
    }
}
<span class="boring">}</span></code></pre>
<h3 id="fslock---file-locking"><a class="header" href="#fslock---file-locking">FsLock - File Locking</a></h3>
<p>Prevents concurrent access conflicts:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsLock: Send + Sync {
    /// Acquire a lock (blocks until available).
    fn lock(&amp;self, handle: Handle, lock_type: LockType) -&gt; Result&lt;(), FsError&gt;;

    /// Try to acquire a lock (non-blocking).
    fn try_lock(&amp;self, handle: Handle, lock_type: LockType) -&gt; Result&lt;bool, FsError&gt;;

    /// Release a lock.
    fn unlock(&amp;self, handle: Handle) -&gt; Result&lt;(), FsError&gt;;
}

pub enum LockType {
    Shared,     // Multiple readers allowed
    Exclusive,  // Single writer, no readers
}
<span class="boring">}</span></code></pre>
<h4 id="implementation-1-1"><a class="header" href="#implementation-1-1">Implementation</a></h4>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsLock for TutorialFs {
    fn lock(&amp;self, handle: Handle, lock_type: LockType) -&gt; Result&lt;(), FsError&gt; {
        let mut inner = self.inner.write().unwrap();

        let state = inner.handles.get_mut(&amp;handle)
            .ok_or(FsError::InvalidHandle { handle })?;

        // Simple implementation: just record the lock
        // Real implementation would check for conflicts
        state.locked = Some(lock_type);

        Ok(())
    }

    fn try_lock(&amp;self, handle: Handle, lock_type: LockType) -&gt; Result&lt;bool, FsError&gt; {
        // For simplicity, always succeed
        self.lock(handle, lock_type)?;
        Ok(true)
    }

    fn unlock(&amp;self, handle: Handle) -&gt; Result&lt;(), FsError&gt; {
        let mut inner = self.inner.write().unwrap();

        let state = inner.handles.get_mut(&amp;handle)
            .ok_or(FsError::InvalidHandle { handle })?;

        state.locked = None;

        Ok(())
    }
}
<span class="boring">}</span></code></pre>
<h3 id="fsxattr---extended-attributes"><a class="header" href="#fsxattr---extended-attributes">FsXattr - Extended Attributes</a></h3>
<p>Store arbitrary metadata on files (like Linux xattr):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait FsXattr: Send + Sync {
    fn get_xattr(&amp;self, path: &amp;Path, name: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt;;
    fn set_xattr(&amp;self, path: &amp;Path, name: &amp;str, value: &amp;[u8]) -&gt; Result&lt;(), FsError&gt;;
    fn remove_xattr(&amp;self, path: &amp;Path, name: &amp;str) -&gt; Result&lt;(), FsError&gt;;
    fn list_xattr(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;String&gt;, FsError&gt;;
}
<span class="boring">}</span></code></pre>
<p>For simplicity, you can return <code>Unsupported</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FsXattr for TutorialFs {
    fn get_xattr(&amp;self, _path: &amp;Path, _name: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        Err(FsError::Unsupported { operation: "xattr".to_string() })
    }
    // ... same for other methods
}
<span class="boring">}</span></code></pre>
<h2 id="putting-it-together"><a class="header" href="#putting-it-together">Putting It Together</a></h2>
<p>With all traits implemented, verify <code>FsPosix</code>:</p>
<pre class="playground"><code class="language-rust">fn use_fs_posix&lt;B: FsPosix&gt;(_: &amp;B) {}

fn main() {
    let fs = TutorialFs::new();
    use_fs_posix(&amp;fs);  // ✅ Full POSIX support!
}</code></pre>
<h2 id="usage-example"><a class="header" href="#usage-example">Usage Example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{FsPosix, OpenFlags, LockType, FsError};

fn atomic_update&lt;B: FsPosix&gt;(
    fs: &amp;B,
    path: &amp;Path,
    updater: impl FnOnce(&amp;[u8]) -&gt; Vec&lt;u8&gt;,
) -&gt; Result&lt;(), FsError&gt; {
    // Open with read/write
    let handle = fs.open(path, OpenFlags::READ | OpenFlags::WRITE)?;
    
    // Lock exclusively
    fs.lock(handle, LockType::Exclusive)?;
    
    // Read current content
    let current = fs.read_at(handle, 0, usize::MAX)?;
    
    // Apply update
    let new_content = updater(&amp;current);
    
    // Write back (truncate by writing from offset 0)
    fs.write_at(handle, 0, &amp;new_content)?;
    
    // Unlock and close
    fs.unlock(handle)?;
    fs.close(handle)?;
    
    Ok(())
}
<span class="boring">}</span></code></pre>
<h2 id="testing-5"><a class="header" href="#testing-5">Testing</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_handle_read_write() {
    let fs = TutorialFs::new();
    
    // Create and open file
    let handle = fs.open(
        Path::new("/file.txt"),
        OpenFlags::READ | OpenFlags::WRITE | OpenFlags::CREATE,
    ).unwrap();
    
    // Write
    fs.write_at(handle, 0, b"Hello, World!").unwrap();
    
    // Read back
    let data = fs.read_at(handle, 0, 5).unwrap();
    assert_eq!(data, b"Hello");
    
    // Read with offset
    let data = fs.read_at(handle, 7, 5).unwrap();
    assert_eq!(data, b"World");
    
    fs.close(handle).unwrap();
}

#[test]
fn test_locking() {
    let fs = TutorialFs::new();
    
    let handle = fs.open(
        Path::new("/locked.txt"),
        OpenFlags::WRITE | OpenFlags::CREATE,
    ).unwrap();
    
    fs.lock(handle, LockType::Exclusive).unwrap();
    fs.write_at(handle, 0, b"Protected data").unwrap();
    fs.unlock(handle).unwrap();
    
    fs.close(handle).unwrap();
}

#[test]
fn test_invalid_handle() {
    let fs = TutorialFs::new();
    
    let invalid = Handle(99999);
    
    assert!(matches!(
        fs.read_at(invalid, 0, 10),
        Err(FsError::InvalidHandle { .. })
    ));
}
<span class="boring">}</span></code></pre>
<h2 id="summary-8"><a class="header" href="#summary-8">Summary</a></h2>
<p>You’ve implemented a complete filesystem backend!</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Layer</th><th>Traits</th></tr>
</thead>
<tbody>
<tr><td><strong>Fs</strong></td><td>FsRead + FsWrite + FsDir</td></tr>
<tr><td><strong>FsFull</strong></td><td>Fs + FsLink + FsPermissions + FsSync + FsStats</td></tr>
<tr><td><strong>FsFuse</strong></td><td>FsFull + FsInode</td></tr>
<tr><td><strong>FsPosix</strong></td><td>FsFuse + FsHandles + FsLock + FsXattr</td></tr>
</tbody>
</table>
</div>
<p>Your <code>TutorialFs</code> now supports:</p>
<ul>
<li>✅ File read/write</li>
<li>✅ Directory operations</li>
<li>✅ Symlinks</li>
<li>✅ Permissions</li>
<li>✅ Filesystem stats</li>
<li>✅ Inode-based access</li>
<li>✅ File handles</li>
<li>✅ File locking</li>
</ul>
<p>🎉 <strong>Congratulations!</strong> You’ve built a full-featured filesystem backend.</p>
<p>Next, learn how to create middleware: <a href="tutorials/middleware/README.html">Implementing Middleware →</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="implementing-middleware-1"><a class="header" href="#implementing-middleware-1">Implementing Middleware</a></h1>
<p>This tutorial teaches you how to create middleware layers that wrap filesystem backends to add cross-cutting functionality.</p>
<h2 id="what-youll-learn-1"><a class="header" href="#what-youll-learn-1">What You’ll Learn</a></h2>
<ul>
<li>The Layer pattern (inspired by Tower)</li>
<li>How to wrap any backend with additional behavior</li>
<li>Creating logging, metrics, caching, and access control layers</li>
<li>Composing multiple layers together</li>
</ul>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<ul>
<li>Completed the <a href="tutorials/backend/README.html">backend tutorial</a> or understand the trait hierarchy</li>
<li>Familiarity with Rust traits and generics</li>
</ul>
<h2 id="the-layer-pattern"><a class="header" href="#the-layer-pattern">The Layer Pattern</a></h2>
<p>Middleware wraps a backend to intercept operations:</p>
<pre><code>              Request
                 │
                 ▼
     ┌─────────────────────┐
     │   Logging Layer     │ ← Logs all operations
     └─────────────────────┘
                 │
                 ▼
     ┌─────────────────────┐
     │   Caching Layer     │ ← Serves from cache
     └─────────────────────┘
                 │
                 ▼
     ┌─────────────────────┐
     │   Actual Backend    │ ← Real filesystem
     └─────────────────────┘
                 │
                 ▼
             Response
</code></pre>
<h2 id="tutorial-structure-1"><a class="header" href="#tutorial-structure-1">Tutorial Structure</a></h2>
<ol>
<li><strong><a href="#the-layer-pattern-1">The Layer Pattern</a></strong> - Understanding the Layer trait</li>
<li><strong><a href="#logging-layer">Logging Layer</a></strong> - Log all operations</li>
<li><strong><a href="#metrics-layer">Metrics Layer</a></strong> - Collect statistics</li>
<li><strong><a href="#caching-layer">Caching Layer</a></strong> - Cache read results</li>
<li><strong><a href="#access-control-layer">Access Control Layer</a></strong> - Restrict operations</li>
<li><strong><a href="#composing-layers">Composing Layers</a></strong> - Stack layers together</li>
</ol>
<h2 id="quick-example-1"><a class="header" href="#quick-example-1">Quick Example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{Fs, Layer};

// Create a backend
let fs = InMemoryFs::new();

// Wrap with logging
let fs = LoggingLayer::new("MyApp").layer(fs);

// Wrap with caching
let fs = CachingLayer::new(Duration::from_secs(60)).layer(fs);

// Use normally - logging and caching are automatic
fs.write(Path::new("/file.txt"), b"Hello").unwrap();
let data = fs.read(Path::new("/file.txt")).unwrap();  // Cached!
<span class="boring">}</span></code></pre>
<p>Let’s start with <a href="#the-layer-pattern-1">The Layer Pattern →</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-layer-pattern-1"><a class="header" href="#the-layer-pattern-1">The Layer Pattern</a></h1>
<p>The Layer pattern allows you to wrap a backend with additional behavior without modifying the backend itself.</p>
<h2 id="the-layer-trait"><a class="header" href="#the-layer-trait">The Layer Trait</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Layer&lt;B&gt; {
    /// The resulting wrapped type.
    type Wrapped;

    /// Wrap the backend, producing a new type.
    fn layer(self, inner: B) -&gt; Self::Wrapped;
}
<span class="boring">}</span></code></pre>
<ul>
<li><code>B</code>: The inner backend type being wrapped</li>
<li><code>Wrapped</code>: The resulting wrapped type (must implement same traits)</li>
<li><code>layer()</code>: Consumes the layer config and backend, produces wrapped backend</li>
</ul>
<h2 id="basic-structure"><a class="header" href="#basic-structure">Basic Structure</a></h2>
<p>Every layer needs two types:</p>
<ol>
<li><strong>Layer type</strong>: Configuration/factory (e.g., <code>LoggingLayer</code>)</li>
<li><strong>Wrapped type</strong>: The actual wrapper (e.g., <code>LoggingFs&lt;B&gt;</code>)</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Layer configuration (the factory)
pub struct MyLayer {
    // Configuration options
}

/// The wrapped backend
pub struct MyWrapper&lt;B&gt; {
    inner: B,
    // Layer state
}

impl&lt;B&gt; Layer&lt;B&gt; for MyLayer {
    type Wrapped = MyWrapper&lt;B&gt;;

    fn layer(self, inner: B) -&gt; Self::Wrapped {
        MyWrapper {
            inner,
            // Initialize state from config
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="pass-through-layer-example"><a class="header" href="#pass-through-layer-example">Pass-Through Layer Example</a></h2>
<p>The simplest layer does nothing—it just forwards all calls:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{Layer, FsRead, FsWrite, FsDir, FsError, Metadata, ReadDirIter};
use std::path::Path;

/// A layer that does nothing.
pub struct PassThroughLayer;

/// Wraps any backend, forwarding all calls.
pub struct PassThrough&lt;B&gt; {
    inner: B,
}

impl&lt;B&gt; Layer&lt;B&gt; for PassThroughLayer {
    type Wrapped = PassThrough&lt;B&gt;;

    fn layer(self, inner: B) -&gt; Self::Wrapped {
        PassThrough { inner }
    }
}

// Forward all trait methods to inner

impl&lt;B: FsRead&gt; FsRead for PassThrough&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        self.inner.read(path)
    }

    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        self.inner.metadata(path)
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; bool {
        self.inner.exists(path)
    }
}

impl&lt;B: FsWrite&gt; FsWrite for PassThrough&lt;B&gt; {
    fn write(&amp;self, path: &amp;Path, content: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        self.inner.write(path, content)
    }

    fn remove_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.inner.remove_file(path)
    }
}

impl&lt;B: FsDir&gt; FsDir for PassThrough&lt;B&gt; {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt; {
        self.inner.read_dir(path)
    }

    fn create_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.inner.create_dir(path)
    }

    fn create_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.inner.create_dir_all(path)
    }

    fn remove_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.inner.remove_dir(path)
    }

    fn remove_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.inner.remove_dir_all(path)
    }

    fn rename(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.inner.rename(from, to)
    }
}
<span class="boring">}</span></code></pre>
<h2 id="why-this-pattern"><a class="header" href="#why-this-pattern">Why This Pattern?</a></h2>
<h3 id="1-composition"><a class="header" href="#1-composition">1. Composition</a></h3>
<p>Layers can be stacked:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fs = backend
    .layer(LoggingLayer::new())
    .layer(CachingLayer::new())
    .layer(MetricsLayer::new());
<span class="boring">}</span></code></pre>
<h3 id="2-separation-of-concerns"><a class="header" href="#2-separation-of-concerns">2. Separation of Concerns</a></h3>
<p>Each layer handles one thing:</p>
<ul>
<li>Logging layer: only logs</li>
<li>Caching layer: only caches</li>
<li>Metrics layer: only counts</li>
</ul>
<h3 id="3-reusability"><a class="header" href="#3-reusability">3. Reusability</a></h3>
<p>Write once, use with any backend:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let memory_fs = InMemoryFs::new().layer(LoggingLayer::new());
let disk_fs = DiskFs::new("/").layer(LoggingLayer::new());
let s3_fs = S3Fs::new(bucket).layer(LoggingLayer::new());
<span class="boring">}</span></code></pre>
<h2 id="the-layerext-trait"><a class="header" href="#the-layerext-trait">The LayerExt Trait</a></h2>
<p>For convenient chaining, use <code>LayerExt</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::LayerExt;

// Instead of:
let fs = LoggingLayer::new().layer(backend);

// You can write:
let fs = backend.layer(LoggingLayer::new());
<span class="boring">}</span></code></pre>
<p><code>LayerExt</code> is automatically implemented for all types.</p>
<h2 id="trait-bounds"><a class="header" href="#trait-bounds">Trait Bounds</a></h2>
<p>The wrapper only implements traits that the inner backend implements:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: FsRead&gt; FsRead for MyWrapper&lt;B&gt; { ... }
//      ^^^^^^
//      Only if B implements FsRead
<span class="boring">}</span></code></pre>
<p>This means:</p>
<ul>
<li>Wrapping an <code>Fs</code> backend gives you an <code>Fs</code> wrapper</li>
<li>Wrapping an <code>FsFull</code> backend gives you an <code>FsFull</code> wrapper</li>
<li>The wrapper “inherits” the inner backend’s capabilities</li>
</ul>
<h2 id="key-points"><a class="header" href="#key-points">Key Points</a></h2>
<ol>
<li><strong>Layer</strong> = Configuration + Factory</li>
<li><strong>Wrapped</strong> = The actual wrapper struct</li>
<li><strong>Forward traits</strong> you want to preserve</li>
<li><strong>Add behavior</strong> in the forwarding methods</li>
<li><strong>Use generics</strong> to work with any backend</li>
</ol>
<p>Next: <a href="#logging-layer">Logging Layer →</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="logging-layer"><a class="header" href="#logging-layer">Logging Layer</a></h1>
<p>A logging layer prints information about each filesystem operation. Useful for:</p>
<ul>
<li>Debugging</li>
<li>Auditing</li>
<li>Understanding access patterns</li>
</ul>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LoggingLayer {
    prefix: String,  // Prefix for log messages
}

pub struct LoggingFs&lt;B&gt; {
    inner: B,
    prefix: String,
}
<span class="boring">}</span></code></pre>
<h2 id="implementation-6"><a class="header" href="#implementation-6">Implementation</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{Layer, FsRead, FsWrite, FsDir, FsError, Metadata, ReadDirIter};
use std::path::Path;
use std::time::Instant;

pub struct LoggingLayer {
    prefix: String,
}

impl LoggingLayer {
    pub fn new(prefix: impl Into&lt;String&gt;) -&gt; Self {
        Self { prefix: prefix.into() }
    }
}

pub struct LoggingFs&lt;B&gt; {
    inner: B,
    prefix: String,
}

impl&lt;B&gt; Layer&lt;B&gt; for LoggingLayer {
    type Wrapped = LoggingFs&lt;B&gt;;

    fn layer(self, inner: B) -&gt; Self::Wrapped {
        LoggingFs {
            inner,
            prefix: self.prefix,
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="logging-fsread"><a class="header" href="#logging-fsread">Logging FsRead</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: FsRead&gt; FsRead for LoggingFs&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let start = Instant::now();
        println!("[{}] read: {}", self.prefix, path.display());
        
        let result = self.inner.read(path);
        let elapsed = start.elapsed();
        
        match &amp;result {
            Ok(data) =&gt; println!(
                "[{}] read: {} → {} bytes ({:?})",
                self.prefix, path.display(), data.len(), elapsed
            ),
            Err(e) =&gt; println!(
                "[{}] read: {} → ERROR: {} ({:?})",
                self.prefix, path.display(), e, elapsed
            ),
        }
        
        result
    }

    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        println!("[{}] metadata: {}", self.prefix, path.display());
        self.inner.metadata(path)
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; bool {
        let result = self.inner.exists(path);
        println!("[{}] exists: {} → {}", self.prefix, path.display(), result);
        result
    }
}
<span class="boring">}</span></code></pre>
<h3 id="logging-fswrite"><a class="header" href="#logging-fswrite">Logging FsWrite</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: FsWrite&gt; FsWrite for LoggingFs&lt;B&gt; {
    fn write(&amp;self, path: &amp;Path, content: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        println!(
            "[{}] write: {} ({} bytes)",
            self.prefix, path.display(), content.len()
        );
        
        let result = self.inner.write(path, content);
        
        match &amp;result {
            Ok(()) =&gt; println!("[{}] write: {} → OK", self.prefix, path.display()),
            Err(e) =&gt; println!("[{}] write: {} → ERROR: {}", self.prefix, path.display(), e),
        }
        
        result
    }

    fn remove_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        println!("[{}] remove_file: {}", self.prefix, path.display());
        self.inner.remove_file(path)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="logging-fsdir"><a class="header" href="#logging-fsdir">Logging FsDir</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: FsDir&gt; FsDir for LoggingFs&lt;B&gt; {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt; {
        println!("[{}] read_dir: {}", self.prefix, path.display());
        self.inner.read_dir(path)
    }

    fn create_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        println!("[{}] create_dir: {}", self.prefix, path.display());
        self.inner.create_dir(path)
    }

    fn create_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        println!("[{}] create_dir_all: {}", self.prefix, path.display());
        self.inner.create_dir_all(path)
    }

    fn remove_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        println!("[{}] remove_dir: {}", self.prefix, path.display());
        self.inner.remove_dir(path)
    }

    fn remove_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        println!("[{}] remove_dir_all: {}", self.prefix, path.display());
        self.inner.remove_dir_all(path)
    }

    fn rename(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        println!(
            "[{}] rename: {} → {}",
            self.prefix, from.display(), to.display()
        );
        self.inner.rename(from, to)
    }
}
<span class="boring">}</span></code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::LayerExt;

let fs = InMemoryFs::new()
    .layer(LoggingLayer::new("FS"));

fs.create_dir(Path::new("/docs")).unwrap();
fs.write(Path::new("/docs/readme.txt"), b"Hello").unwrap();
let _ = fs.read(Path::new("/docs/readme.txt")).unwrap();
<span class="boring">}</span></code></pre>
<p>Output:</p>
<pre><code>[FS] create_dir: /docs
[FS] write: /docs/readme.txt (5 bytes)
[FS] write: /docs/readme.txt → OK
[FS] read: /docs/readme.txt
[FS] read: /docs/readme.txt → 5 bytes (45µs)
</code></pre>
<h2 id="variations"><a class="header" href="#variations">Variations</a></h2>
<h3 id="log-level-support"><a class="header" href="#log-level-support">Log Level Support</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LoggingLayer {
    prefix: String,
    level: LogLevel,
}

pub enum LogLevel {
    Debug,
    Info,
    Warn,
}

impl&lt;B: FsRead&gt; FsRead for LoggingFs&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        if self.level &lt;= LogLevel::Debug {
            println!("[{}] read: {}", self.prefix, path.display());
        }
        // ...
    }
}
<span class="boring">}</span></code></pre>
<h3 id="log-to-filecustom-logger"><a class="header" href="#log-to-filecustom-logger">Log to File/Custom Logger</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;

pub trait Logger: Send + Sync {
    fn log(&amp;self, message: &amp;str);
}

pub struct LoggingLayer&lt;L&gt; {
    logger: Arc&lt;L&gt;,
}

pub struct LoggingFs&lt;B, L&gt; {
    inner: B,
    logger: Arc&lt;L&gt;,
}
<span class="boring">}</span></code></pre>
<h3 id="filter-by-path"><a class="header" href="#filter-by-path">Filter by Path</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LoggingLayer {
    prefix: String,
    filter: Option&lt;PathBuf&gt;,  // Only log operations under this path
}
<span class="boring">}</span></code></pre>
<h2 id="key-points-1"><a class="header" href="#key-points-1">Key Points</a></h2>
<ol>
<li><strong>Log before and after</strong> - Shows timing and results</li>
<li><strong>Include context</strong> - Path, size, duration</li>
<li><strong>Log errors</strong> - Don’t suppress, just log and forward</li>
<li><strong>Configurable</strong> - Prefix, level, filter</li>
</ol>
<p>Next: <a href="#metrics-layer">Metrics Layer →</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="metrics-layer"><a class="header" href="#metrics-layer">Metrics Layer</a></h1>
<p>A metrics layer collects statistics about filesystem usage:</p>
<ul>
<li>Operation counts</li>
<li>Bytes read/written</li>
<li>Error counts</li>
<li>Latency histograms</li>
</ul>
<h2 id="design-1"><a class="header" href="#design-1">Design</a></h2>
<p>Use atomic counters for thread safety:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;

#[derive(Debug, Default)]
pub struct Metrics {
    pub reads: AtomicU64,
    pub writes: AtomicU64,
    pub bytes_read: AtomicU64,
    pub bytes_written: AtomicU64,
    pub errors: AtomicU64,
}

impl Metrics {
    pub fn new() -&gt; Arc&lt;Self&gt; {
        Arc::new(Self::default())
    }

    pub fn summary(&amp;self) -&gt; String {
        format!(
            "reads={}, writes={}, bytes_read={}, bytes_written={}, errors={}",
            self.reads.load(Ordering::Relaxed),
            self.writes.load(Ordering::Relaxed),
            self.bytes_read.load(Ordering::Relaxed),
            self.bytes_written.load(Ordering::Relaxed),
            self.errors.load(Ordering::Relaxed),
        )
    }
}
<span class="boring">}</span></code></pre>
<h2 id="implementation-7"><a class="header" href="#implementation-7">Implementation</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{Layer, FsRead, FsWrite, FsDir, FsError, Metadata, ReadDirIter};
use std::path::Path;

pub struct MetricsLayer {
    metrics: Arc&lt;Metrics&gt;,
}

impl MetricsLayer {
    pub fn new(metrics: Arc&lt;Metrics&gt;) -&gt; Self {
        Self { metrics }
    }
}

pub struct MetricsFs&lt;B&gt; {
    inner: B,
    metrics: Arc&lt;Metrics&gt;,
}

impl&lt;B&gt; Layer&lt;B&gt; for MetricsLayer {
    type Wrapped = MetricsFs&lt;B&gt;;

    fn layer(self, inner: B) -&gt; Self::Wrapped {
        MetricsFs {
            inner,
            metrics: self.metrics,
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="counting-fsread"><a class="header" href="#counting-fsread">Counting FsRead</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: FsRead&gt; FsRead for MetricsFs&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        self.metrics.reads.fetch_add(1, Ordering::Relaxed);
        
        match self.inner.read(path) {
            Ok(data) =&gt; {
                self.metrics.bytes_read
                    .fetch_add(data.len() as u64, Ordering::Relaxed);
                Ok(data)
            }
            Err(e) =&gt; {
                self.metrics.errors.fetch_add(1, Ordering::Relaxed);
                Err(e)
            }
        }
    }

    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        self.inner.metadata(path)
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; bool {
        self.inner.exists(path)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="counting-fswrite"><a class="header" href="#counting-fswrite">Counting FsWrite</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: FsWrite&gt; FsWrite for MetricsFs&lt;B&gt; {
    fn write(&amp;self, path: &amp;Path, content: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        self.metrics.writes.fetch_add(1, Ordering::Relaxed);
        
        match self.inner.write(path, content) {
            Ok(()) =&gt; {
                self.metrics.bytes_written
                    .fetch_add(content.len() as u64, Ordering::Relaxed);
                Ok(())
            }
            Err(e) =&gt; {
                self.metrics.errors.fetch_add(1, Ordering::Relaxed);
                Err(e)
            }
        }
    }

    fn remove_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.inner.remove_file(path)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="forwarding-fsdir"><a class="header" href="#forwarding-fsdir">Forwarding FsDir</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: FsDir&gt; FsDir for MetricsFs&lt;B&gt; {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt; {
        self.inner.read_dir(path)
    }

    fn create_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.inner.create_dir(path)
    }

    fn create_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.inner.create_dir_all(path)
    }

    fn remove_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.inner.remove_dir(path)
    }

    fn remove_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.inner.remove_dir_all(path)
    }

    fn rename(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.inner.rename(from, to)
    }
}
<span class="boring">}</span></code></pre>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::LayerExt;

// Create shared metrics
let metrics = Metrics::new();

let fs = InMemoryFs::new()
    .layer(MetricsLayer::new(metrics.clone()));

// Use the filesystem
fs.write(Path::new("/a.txt"), b"Hello").unwrap();
fs.write(Path::new("/b.txt"), b"World!").unwrap();
fs.read(Path::new("/a.txt")).unwrap();
fs.read(Path::new("/b.txt")).unwrap();
fs.read(Path::new("/a.txt")).unwrap();

// Check metrics
println!("{}", metrics.summary());
// Output: reads=3, writes=2, bytes_read=16, bytes_written=11, errors=0
<span class="boring">}</span></code></pre>
<h2 id="advanced-metrics"><a class="header" href="#advanced-metrics">Advanced Metrics</a></h2>
<h3 id="latency-tracking"><a class="header" href="#latency-tracking">Latency Tracking</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::{Duration, Instant};
use std::sync::RwLock;

pub struct DetailedMetrics {
    pub reads: AtomicU64,
    pub read_latencies: RwLock&lt;Vec&lt;Duration&gt;&gt;,  // For percentile calculations
}

impl&lt;B: FsRead&gt; FsRead for MetricsFs&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let start = Instant::now();
        let result = self.inner.read(path);
        let elapsed = start.elapsed();
        
        self.metrics.reads.fetch_add(1, Ordering::Relaxed);
        self.metrics.read_latencies.write().unwrap().push(elapsed);
        
        result
    }
}
<span class="boring">}</span></code></pre>
<h3 id="per-path-metrics"><a class="header" href="#per-path-metrics">Per-Path Metrics</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

pub struct PathMetrics {
    pub by_path: RwLock&lt;HashMap&lt;PathBuf, u64&gt;&gt;,
}

impl&lt;B: FsRead&gt; FsRead for PathMetricsFs&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let result = self.inner.read(path);
        
        if result.is_ok() {
            let mut by_path = self.metrics.by_path.write().unwrap();
            *by_path.entry(path.to_path_buf()).or_default() += 1;
        }
        
        result
    }
}
<span class="boring">}</span></code></pre>
<h3 id="prometheusopentelemetry-integration"><a class="header" href="#prometheusopentelemetry-integration">Prometheus/OpenTelemetry Integration</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pseudo-code for real metrics systems
pub struct PrometheusMetrics {
    reads: prometheus::Counter,
    bytes_read: prometheus::Counter,
    read_duration: prometheus::Histogram,
}

impl&lt;B: FsRead&gt; FsRead for PrometheusFs&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let timer = self.metrics.read_duration.start_timer();
        let result = self.inner.read(path);
        timer.observe_duration();
        
        self.metrics.reads.inc();
        if let Ok(data) = &amp;result {
            self.metrics.bytes_read.inc_by(data.len() as f64);
        }
        
        result
    }
}
<span class="boring">}</span></code></pre>
<h2 id="key-points-2"><a class="header" href="#key-points-2">Key Points</a></h2>
<ol>
<li><strong>Use atomics</strong> for thread-safe counting</li>
<li><strong>Share metrics</strong> via <code>Arc</code> to read from outside</li>
<li><strong>Count before/after</strong> for accurate error tracking</li>
<li><strong>Consider scope</strong> - global vs per-path vs per-operation</li>
</ol>
<p>Next: <a href="#caching-layer">Caching Layer →</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="caching-layer"><a class="header" href="#caching-layer">Caching Layer</a></h1>
<p>A caching layer stores read results to avoid repeated backend access. Essential for:</p>
<ul>
<li>Remote backends (S3, network filesystems)</li>
<li>Slow storage</li>
<li>Reducing API calls/costs</li>
</ul>
<h2 id="design-decisions"><a class="header" href="#design-decisions">Design Decisions</a></h2>
<ol>
<li><strong>What to cache</strong>: File contents, metadata, or both</li>
<li><strong>TTL</strong>: How long entries remain valid</li>
<li><strong>Invalidation</strong>: When to remove stale entries</li>
<li><strong>Size limits</strong>: Maximum cache size (LRU eviction)</li>
</ol>
<h2 id="basic-implementation"><a class="header" href="#basic-implementation">Basic Implementation</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{Layer, FsRead, FsWrite, FsDir, FsError, Metadata, ReadDirIter};
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::sync::RwLock;
use std::time::{Duration, Instant};

pub struct CachingLayer {
    ttl: Duration,
}

impl CachingLayer {
    pub fn new(ttl: Duration) -&gt; Self {
        Self { ttl }
    }
}

struct CacheEntry {
    data: Vec&lt;u8&gt;,
    expires_at: Instant,
}

pub struct CachingFs&lt;B&gt; {
    inner: B,
    cache: RwLock&lt;HashMap&lt;PathBuf, CacheEntry&gt;&gt;,
    ttl: Duration,
}

impl&lt;B&gt; Layer&lt;B&gt; for CachingLayer {
    type Wrapped = CachingFs&lt;B&gt;;

    fn layer(self, inner: B) -&gt; Self::Wrapped {
        CachingFs {
            inner,
            cache: RwLock::new(HashMap::new()),
            ttl: self.ttl,
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="caching-reads"><a class="header" href="#caching-reads">Caching Reads</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: FsRead&gt; FsRead for CachingFs&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        let path_buf = path.to_path_buf();

        // Check cache first
        {
            let cache = self.cache.read().unwrap();
            if let Some(entry) = cache.get(&amp;path_buf) {
                if entry.expires_at &gt; Instant::now() {
                    return Ok(entry.data.clone());  // Cache hit!
                }
            }
        }

        // Cache miss - read from backend
        let data = self.inner.read(path)?;

        // Store in cache
        {
            let mut cache = self.cache.write().unwrap();
            cache.insert(path_buf, CacheEntry {
                data: data.clone(),
                expires_at: Instant::now() + self.ttl,
            });
        }

        Ok(data)
    }

    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        // Could cache metadata too
        self.inner.metadata(path)
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; bool {
        self.inner.exists(path)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="invalidating-on-write"><a class="header" href="#invalidating-on-write">Invalidating on Write</a></h3>
<p><strong>Critical</strong>: Writes must invalidate cached entries!</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: FsWrite&gt; FsWrite for CachingFs&lt;B&gt; {
    fn write(&amp;self, path: &amp;Path, content: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        // Invalidate cache entry BEFORE writing
        {
            let mut cache = self.cache.write().unwrap();
            cache.remove(path);
        }

        self.inner.write(path, content)
    }

    fn remove_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        {
            let mut cache = self.cache.write().unwrap();
            cache.remove(path);
        }

        self.inner.remove_file(path)
    }
}
<span class="boring">}</span></code></pre>
<h3 id="handling-directory-operations"><a class="header" href="#handling-directory-operations">Handling Directory Operations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B: FsDir&gt; FsDir for CachingFs&lt;B&gt; {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt; {
        self.inner.read_dir(path)
    }

    fn create_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.inner.create_dir(path)
    }

    fn create_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.inner.create_dir_all(path)
    }

    fn remove_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.inner.remove_dir(path)
    }

    fn remove_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        // Invalidate ALL entries under this path
        {
            let mut cache = self.cache.write().unwrap();
            cache.retain(|p, _| !p.starts_with(path));
        }

        self.inner.remove_dir_all(path)
    }

    fn rename(&amp;self, from: &amp;Path, to: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        // Invalidate both paths
        {
            let mut cache = self.cache.write().unwrap();
            cache.remove(from);
            cache.remove(to);
        }

        self.inner.rename(from, to)
    }
}
<span class="boring">}</span></code></pre>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::LayerExt;
use std::time::Duration;

let fs = InMemoryFs::new()
    .layer(CachingLayer::new(Duration::from_secs(60)));

// First read - cache miss, reads from backend
let data1 = fs.read(Path::new("/file.txt")).unwrap();

// Second read - cache hit, returns cached data
let data2 = fs.read(Path::new("/file.txt")).unwrap();

// After write, cache is invalidated
fs.write(Path::new("/file.txt"), b"new content").unwrap();

// This read fetches fresh data
let data3 = fs.read(Path::new("/file.txt")).unwrap();
<span class="boring">}</span></code></pre>
<h2 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h2>
<h3 id="lru-eviction"><a class="header" href="#lru-eviction">LRU Eviction</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::VecDeque;

struct LruCache {
    entries: HashMap&lt;PathBuf, CacheEntry&gt;,
    order: VecDeque&lt;PathBuf&gt;,  // Oldest first
    max_size: usize,
}

impl LruCache {
    fn insert(&amp;mut self, path: PathBuf, data: Vec&lt;u8&gt;, ttl: Duration) {
        // Evict if at capacity
        while self.entries.len() &gt;= self.max_size {
            if let Some(oldest) = self.order.pop_front() {
                self.entries.remove(&amp;oldest);
            }
        }
        
        self.entries.insert(path.clone(), CacheEntry {
            data,
            expires_at: Instant::now() + ttl,
        });
        self.order.push_back(path);
    }
}
<span class="boring">}</span></code></pre>
<h3 id="size-limited-cache"><a class="header" href="#size-limited-cache">Size-Limited Cache</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SizeAwareCache {
    entries: HashMap&lt;PathBuf, CacheEntry&gt;,
    total_bytes: usize,
    max_bytes: usize,
}

impl SizeAwareCache {
    fn insert(&amp;mut self, path: PathBuf, data: Vec&lt;u8&gt;, ttl: Duration) {
        let size = data.len();
        
        // Don't cache if too large
        if size &gt; self.max_bytes / 10 {
            return;
        }
        
        // Evict until space available
        while self.total_bytes + size &gt; self.max_bytes {
            // Evict oldest/smallest/least-used
        }
        
        self.total_bytes += size;
        self.entries.insert(path, CacheEntry { data, expires_at: ... });
    }
}
<span class="boring">}</span></code></pre>
<h3 id="negative-caching"><a class="header" href="#negative-caching">Negative Caching</a></h3>
<p>Cache “not found” results to avoid repeated lookups:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum CachedResult {
    Found(Vec&lt;u8&gt;),
    NotFound,
}

fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
    if let Some(cached) = self.get_cached(path) {
        match cached {
            CachedResult::Found(data) =&gt; return Ok(data),
            CachedResult::NotFound =&gt; return Err(FsError::NotFound { ... }),
        }
    }
    
    match self.inner.read(path) {
        Ok(data) =&gt; {
            self.cache(path, CachedResult::Found(data.clone()));
            Ok(data)
        }
        Err(FsError::NotFound { .. }) =&gt; {
            self.cache(path, CachedResult::NotFound);
            Err(FsError::NotFound { path: path.to_path_buf() })
        }
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}</span></code></pre>
<h2 id="cache-consistency"><a class="header" href="#cache-consistency">Cache Consistency</a></h2>
<h3 id="strong-consistency"><a class="header" href="#strong-consistency">Strong Consistency</a></h3>
<p>Invalidate on every write operation. Safe but may miss external changes.</p>
<h3 id="eventual-consistency"><a class="header" href="#eventual-consistency">Eventual Consistency</a></h3>
<p>Use short TTLs. Allows stale reads but simpler.</p>
<h3 id="write-through"><a class="header" href="#write-through">Write-Through</a></h3>
<p>Update cache on write instead of invalidating:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn write(&amp;self, path: &amp;Path, content: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
    self.inner.write(path, content)?;
    
    // Update cache with new content
    let mut cache = self.cache.write().unwrap();
    cache.insert(path.to_path_buf(), CacheEntry {
        data: content.to_vec(),
        expires_at: Instant::now() + self.ttl,
    });
    
    Ok(())
}
<span class="boring">}</span></code></pre>
<h2 id="key-points-3"><a class="header" href="#key-points-3">Key Points</a></h2>
<ol>
<li><strong>Always invalidate on writes</strong> - Stale cache is worse than no cache</li>
<li><strong>Consider TTL carefully</strong> - Too long = stale data, too short = no benefit</li>
<li><strong>Handle directory operations</strong> - <code>remove_dir_all</code> affects many paths</li>
<li><strong>Memory limits</strong> - Unbounded caches can cause OOM</li>
</ol>
<p>Next: <a href="#access-control-layer">Access Control Layer →</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="access-control-layer"><a class="header" href="#access-control-layer">Access Control Layer</a></h1>
<p>An access control layer restricts operations based on rules:</p>
<ul>
<li>Read-only mode</li>
<li>Path restrictions</li>
<li>User-based permissions</li>
</ul>
<h2 id="design-2"><a class="header" href="#design-2">Design</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum AccessRule {
    /// Deny all write operations
    ReadOnly,
    
    /// Only allow operations under a specific path
    RestrictToPath(PathBuf),
    
    /// Custom rule function
    Custom(Box&lt;dyn Fn(&amp;Path, Operation) -&gt; bool + Send + Sync&gt;),
}

pub enum Operation {
    Read,
    Write,
    Delete,
    List,
    Create,
}
<span class="boring">}</span></code></pre>
<h2 id="read-only-implementation"><a class="header" href="#read-only-implementation">Read-Only Implementation</a></h2>
<p>The simplest access control: block all writes.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{Layer, FsRead, FsWrite, FsDir, FsError, Metadata, ReadDirIter};
use std::path::Path;

pub struct ReadOnlyLayer;

pub struct ReadOnlyFs&lt;B&gt; {
    inner: B,
}

impl&lt;B&gt; Layer&lt;B&gt; for ReadOnlyLayer {
    type Wrapped = ReadOnlyFs&lt;B&gt;;

    fn layer(self, inner: B) -&gt; Self::Wrapped {
        ReadOnlyFs { inner }
    }
}

// Forward all reads unchanged
impl&lt;B: FsRead&gt; FsRead for ReadOnlyFs&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        self.inner.read(path)
    }

    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        self.inner.metadata(path)
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; bool {
        self.inner.exists(path)
    }
}

// Block all writes
impl&lt;B: FsWrite&gt; FsWrite for ReadOnlyFs&lt;B&gt; {
    fn write(&amp;self, path: &amp;Path, _content: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::PermissionDenied { path: path.to_path_buf() })
    }

    fn remove_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::PermissionDenied { path: path.to_path_buf() })
    }
}

impl&lt;B: FsDir&gt; FsDir for ReadOnlyFs&lt;B&gt; {
    fn read_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;ReadDirIter, FsError&gt; {
        self.inner.read_dir(path)  // Reading is allowed
    }

    fn create_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::PermissionDenied { path: path.to_path_buf() })
    }

    fn create_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::PermissionDenied { path: path.to_path_buf() })
    }

    fn remove_dir(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::PermissionDenied { path: path.to_path_buf() })
    }

    fn remove_dir_all(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::PermissionDenied { path: path.to_path_buf() })
    }

    fn rename(&amp;self, from: &amp;Path, _to: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        Err(FsError::PermissionDenied { path: from.to_path_buf() })
    }
}
<span class="boring">}</span></code></pre>
<h2 id="path-restricted-implementation"><a class="header" href="#path-restricted-implementation">Path-Restricted Implementation</a></h2>
<p>Only allow access under certain paths:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::PathBuf;

pub struct PathRestrictedLayer {
    allowed_paths: Vec&lt;PathBuf&gt;,
}

impl PathRestrictedLayer {
    pub fn new(paths: Vec&lt;PathBuf&gt;) -&gt; Self {
        Self { allowed_paths: paths }
    }
    
    pub fn single(path: impl Into&lt;PathBuf&gt;) -&gt; Self {
        Self { allowed_paths: vec![path.into()] }
    }
}

pub struct PathRestrictedFs&lt;B&gt; {
    inner: B,
    allowed_paths: Vec&lt;PathBuf&gt;,
}

impl&lt;B&gt; PathRestrictedFs&lt;B&gt; {
    fn check_path(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        for allowed in &amp;self.allowed_paths {
            if path.starts_with(allowed) {
                return Ok(());
            }
        }
        Err(FsError::PermissionDenied { path: path.to_path_buf() })
    }
}

impl&lt;B&gt; Layer&lt;B&gt; for PathRestrictedLayer {
    type Wrapped = PathRestrictedFs&lt;B&gt;;

    fn layer(self, inner: B) -&gt; Self::Wrapped {
        PathRestrictedFs {
            inner,
            allowed_paths: self.allowed_paths,
        }
    }
}

impl&lt;B: FsRead&gt; FsRead for PathRestrictedFs&lt;B&gt; {
    fn read(&amp;self, path: &amp;Path) -&gt; Result&lt;Vec&lt;u8&gt;, FsError&gt; {
        self.check_path(path)?;
        self.inner.read(path)
    }

    fn metadata(&amp;self, path: &amp;Path) -&gt; Result&lt;Metadata, FsError&gt; {
        self.check_path(path)?;
        self.inner.metadata(path)
    }

    fn exists(&amp;self, path: &amp;Path) -&gt; bool {
        if self.check_path(path).is_err() {
            return false;  // Pretend it doesn't exist
        }
        self.inner.exists(path)
    }
}

impl&lt;B: FsWrite&gt; FsWrite for PathRestrictedFs&lt;B&gt; {
    fn write(&amp;self, path: &amp;Path, content: &amp;[u8]) -&gt; Result&lt;(), FsError&gt; {
        self.check_path(path)?;
        self.inner.write(path, content)
    }

    fn remove_file(&amp;self, path: &amp;Path) -&gt; Result&lt;(), FsError&gt; {
        self.check_path(path)?;
        self.inner.remove_file(path)
    }
}

// FsDir implementation similar...
<span class="boring">}</span></code></pre>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<h3 id="read-only-mode"><a class="header" href="#read-only-mode">Read-Only Mode</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::LayerExt;

// Populate the filesystem first
let fs = InMemoryFs::new();
fs.create_dir(Path::new("/data")).unwrap();
fs.write(Path::new("/data/file.txt"), b"content").unwrap();

// Now make it read-only
let fs = fs.layer(ReadOnlyLayer);

// Reading works
let data = fs.read(Path::new("/data/file.txt")).unwrap();

// Writing fails
match fs.write(Path::new("/data/new.txt"), b"test") {
    Err(FsError::PermissionDenied { .. }) =&gt; println!("Blocked!"),
    _ =&gt; panic!("Should have been blocked"),
}
<span class="boring">}</span></code></pre>
<h3 id="path-restriction"><a class="header" href="#path-restriction">Path Restriction</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fs = InMemoryFs::new();
fs.create_dir_all(Path::new("/allowed/subdir")).unwrap();
fs.create_dir(Path::new("/forbidden")).unwrap();
fs.write(Path::new("/allowed/file.txt"), b"ok").unwrap();
fs.write(Path::new("/forbidden/secret.txt"), b"hidden").unwrap();

// Restrict to /allowed only
let fs = fs.layer(PathRestrictedLayer::single("/allowed"));

// This works
let data = fs.read(Path::new("/allowed/file.txt")).unwrap();

// This fails
match fs.read(Path::new("/forbidden/secret.txt")) {
    Err(FsError::PermissionDenied { .. }) =&gt; println!("Access denied!"),
    _ =&gt; panic!("Should have been denied"),
}
<span class="boring">}</span></code></pre>
<h2 id="advanced-custom-rules"><a class="header" href="#advanced-custom-rules">Advanced: Custom Rules</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CustomAccessLayer&lt;F&gt; {
    checker: F,
}

impl&lt;F&gt; CustomAccessLayer&lt;F&gt;
where
    F: Fn(&amp;Path, Operation) -&gt; bool + Send + Sync + Clone,
{
    pub fn new(checker: F) -&gt; Self {
        Self { checker }
    }
}

// Example: Allow reads anywhere, writes only to /tmp
let fs = backend.layer(CustomAccessLayer::new(|path, op| {
    match op {
        Operation::Read | Operation::List =&gt; true,
        Operation::Write | Operation::Create | Operation::Delete =&gt; {
            path.starts_with("/tmp")
        }
    }
}));
<span class="boring">}</span></code></pre>
<h2 id="combining-with-other-layers"><a class="header" href="#combining-with-other-layers">Combining with Other Layers</a></h2>
<p>Access control should usually be the <strong>outermost</strong> layer:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fs = InMemoryFs::new()
    .layer(CachingLayer::new(Duration::from_secs(60)))
    .layer(MetricsLayer::new(metrics.clone()))
    .layer(LoggingLayer::new("FS"))
    .layer(ReadOnlyLayer);  // Outermost - checked first

// Flow: ReadOnly -&gt; Logging -&gt; Metrics -&gt; Caching -&gt; Backend
<span class="boring">}</span></code></pre>
<p>This way:</p>
<ol>
<li>Access control rejects unauthorized requests immediately</li>
<li>Logging sees the rejection</li>
<li>Metrics don’t count blocked requests (if desired)</li>
</ol>
<h2 id="key-points-4"><a class="header" href="#key-points-4">Key Points</a></h2>
<ol>
<li><strong>Return <code>PermissionDenied</code></strong> for blocked operations</li>
<li><strong>Check early</strong> - Don’t do work before validating access</li>
<li><strong>Consider <code>exists()</code></strong> - Should forbidden paths appear to not exist?</li>
<li><strong>Layer order matters</strong> - Put access control outermost</li>
</ol>
<p>Next: <a href="#composing-layers">Composing Layers →</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="composing-layers"><a class="header" href="#composing-layers">Composing Layers</a></h1>
<p>The power of layers comes from composition. Stack multiple layers to combine functionality.</p>
<h2 id="basic-composition"><a class="header" href="#basic-composition">Basic Composition</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::LayerExt;

let fs = InMemoryFs::new()
    .layer(CachingLayer::new(Duration::from_secs(60)))
    .layer(MetricsLayer::new(metrics.clone()))
    .layer(LoggingLayer::new("FS"));
<span class="boring">}</span></code></pre>
<h2 id="understanding-layer-order"><a class="header" href="#understanding-layer-order">Understanding Layer Order</a></h2>
<p>When you compose layers:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>backend.layer(A).layer(B).layer(C)
<span class="boring">}</span></code></pre>
<p>The result is: <strong>C wraps B wraps A wraps backend</strong></p>
<pre><code>Request → C → B → A → Backend → A → B → C → Response
          ↓   ↓   ↓            ↑   ↑   ↑
        (1) (2) (3)          (3) (2) (1)
</code></pre>
<p><strong>Outer layers see requests first and responses last.</strong></p>
<h2 id="order-matters"><a class="header" href="#order-matters">Order Matters!</a></h2>
<h3 id="example-logging--caching"><a class="header" href="#example-logging--caching">Example: Logging + Caching</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Option 1: Logging outside Caching
let fs = backend
    .layer(CachingLayer::new(ttl))
    .layer(LoggingLayer::new("FS"));

// Log shows: read /file.txt (even for cache hits)
// Because logging is outside, it sees ALL requests
<span class="boring">}</span></code></pre>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Option 2: Caching outside Logging
let fs = backend
    .layer(LoggingLayer::new("FS"))
    .layer(CachingLayer::new(ttl));

// Log shows: read /file.txt (only for cache misses)
// Because cache handles request before it reaches logging
<span class="boring">}</span></code></pre>
<h3 id="example-metrics--caching"><a class="header" href="#example-metrics--caching">Example: Metrics + Caching</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Metrics outside Caching - counts ALL reads
let fs = backend
    .layer(CachingLayer::new(ttl))
    .layer(MetricsLayer::new(m.clone()));
// metrics.reads = 100 (total requests)

// Caching outside Metrics - counts only cache misses
let fs = backend
    .layer(MetricsLayer::new(m.clone()))
    .layer(CachingLayer::new(ttl));
// metrics.reads = 10 (backend hits only)
<span class="boring">}</span></code></pre>
<h2 id="recommended-layer-order"><a class="header" href="#recommended-layer-order">Recommended Layer Order</a></h2>
<p>From innermost to outermost:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fs = backend
    // 1. Transformations (encryption, compression)
    .layer(EncryptionLayer::new(key))
    
    // 2. Caching (after transformation)
    .layer(CachingLayer::new(Duration::from_secs(60)))
    
    // 3. Retry/resilience
    .layer(RetryLayer::new(3))
    
    // 4. Metrics (count actual operations)
    .layer(MetricsLayer::new(metrics.clone()))
    
    // 5. Logging (see everything)
    .layer(LoggingLayer::new("FS"))
    
    // 6. Access control (reject early)
    .layer(AccessControlLayer::new(rules));
<span class="boring">}</span></code></pre>
<p>Reasoning:</p>
<ul>
<li><strong>Encryption</strong> must wrap raw backend to encrypt all data</li>
<li><strong>Caching</strong> stores encrypted data (or plaintext, depending on requirements)</li>
<li><strong>Retry</strong> retries failed operations</li>
<li><strong>Metrics</strong> count operations that reach this point</li>
<li><strong>Logging</strong> logs everything including rejections</li>
<li><strong>Access control</strong> rejects unauthorized requests immediately</li>
</ul>
<h2 id="type-complexity"><a class="header" href="#type-complexity">Type Complexity</a></h2>
<p>Each layer adds a wrapper type:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fs: LoggingFs&lt;MetricsFs&lt;CachingFs&lt;InMemoryFs&gt;&gt;&gt; = ...;
<span class="boring">}</span></code></pre>
<p>This can get unwieldy. Solutions:</p>
<h3 id="1-type-alias"><a class="header" href="#1-type-alias">1. Type Alias</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type MyFs = LoggingFs&lt;MetricsFs&lt;CachingFs&lt;InMemoryFs&gt;&gt;&gt;;

fn create_fs() -&gt; MyFs {
    InMemoryFs::new()
        .layer(CachingLayer::new(ttl))
        .layer(MetricsLayer::new(metrics))
        .layer(LoggingLayer::new("FS"))
}
<span class="boring">}</span></code></pre>
<h3 id="2-box-with-dyn-fs"><a class="header" href="#2-box-with-dyn-fs">2. Box with dyn Fs</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_fs() -&gt; Box&lt;dyn Fs&gt; {
    let fs = InMemoryFs::new()
        .layer(CachingLayer::new(ttl))
        .layer(MetricsLayer::new(metrics))
        .layer(LoggingLayer::new("FS"));
    
    Box::new(fs)
}
<span class="boring">}</span></code></pre>
<h3 id="3-impl-trait"><a class="header" href="#3-impl-trait">3. impl Trait</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_fs() -&gt; impl Fs {
    InMemoryFs::new()
        .layer(CachingLayer::new(ttl))
        .layer(MetricsLayer::new(metrics))
        .layer(LoggingLayer::new("FS"))
}
<span class="boring">}</span></code></pre>
<h2 id="runtime-composition"><a class="header" href="#runtime-composition">Runtime Composition</a></h2>
<p>For dynamic layer selection:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_fs(config: &amp;Config) -&gt; Box&lt;dyn Fs&gt; {
    let mut fs: Box&lt;dyn Fs&gt; = Box::new(InMemoryFs::new());
    
    if config.enable_caching {
        fs = Box::new(CachingLayer::new(config.cache_ttl).layer(fs));
    }
    
    if config.enable_logging {
        fs = Box::new(LoggingLayer::new(&amp;config.log_prefix).layer(fs));
    }
    
    if config.read_only {
        fs = Box::new(ReadOnlyLayer.layer(fs));
    }
    
    fs
}
<span class="boring">}</span></code></pre>
<p>Note: This requires layers to work with <code>Box&lt;dyn Fs&gt;</code>, which means implementing traits for the boxed type.</p>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<pre class="playground"><code class="language-rust">use anyfs_backend::{Fs, LayerExt};
use std::path::Path;
use std::time::Duration;

fn main() {
    // Create shared metrics
    let metrics = Metrics::new();
    
    // Build the layered filesystem
    let fs = InMemoryFs::new()
        .layer(CachingLayer::new(Duration::from_secs(60)))
        .layer(MetricsLayer::new(metrics.clone()))
        .layer(LoggingLayer::new("APP"));
    
    // Setup
    fs.create_dir(Path::new("/data")).unwrap();
    fs.write(Path::new("/data/config.json"), b"{}").unwrap();
    
    // Multiple reads - watch cache behavior
    for i in 0..5 {
        let _ = fs.read(Path::new("/data/config.json"));
        println!("After read {}: {}", i + 1, metrics.summary());
    }
    
    // Output shows:
    // - All 5 reads logged (logging is outermost)
    // - Only 1 read in metrics (cache handles the rest)
}</code></pre>
<h2 id="testing-layered-systems"><a class="header" href="#testing-layered-systems">Testing Layered Systems</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_layer_composition() {
    let metrics = Metrics::new();
    
    let fs = InMemoryFs::new()
        .layer(CachingLayer::new(Duration::from_secs(60)))
        .layer(MetricsLayer::new(metrics.clone()));
    
    fs.write(Path::new("/test.txt"), b"data").unwrap();
    
    // First read - cache miss, hits metrics
    fs.read(Path::new("/test.txt")).unwrap();
    assert_eq!(metrics.reads.load(Ordering::Relaxed), 1);
    
    // Second read - cache hit, doesn't hit metrics
    fs.read(Path::new("/test.txt")).unwrap();
    assert_eq!(metrics.reads.load(Ordering::Relaxed), 1);  // Still 1!
    
    // Write invalidates cache
    fs.write(Path::new("/test.txt"), b"new").unwrap();
    
    // Next read - cache miss again
    fs.read(Path::new("/test.txt")).unwrap();
    assert_eq!(metrics.reads.load(Ordering::Relaxed), 2);
}
<span class="boring">}</span></code></pre>
<h2 id="summary-9"><a class="header" href="#summary-9">Summary</a></h2>
<ol>
<li><strong>Compose with <code>.layer()</code></strong> - Clean, fluent API</li>
<li><strong>Order matters</strong> - Outer layers see requests first</li>
<li><strong>Think about what each layer should see</strong> - Metrics before or after cache?</li>
<li><strong>Use type aliases or <code>impl Trait</code></strong> - Manage type complexity</li>
<li><strong>Test the composition</strong> - Verify layers interact correctly</li>
</ol>
<p>🎉 <strong>Congratulations!</strong> You now know how to:</p>
<ul>
<li>Create middleware layers</li>
<li>Log, measure, cache, and control access</li>
<li>Compose layers for powerful, reusable functionality</li>
</ul>
<p>Go build something awesome!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-types"><a class="header" href="#error-types">Error Types</a></h1>
<p>AnyFS defines a unified error type for all filesystem operations.</p>
<h2 id="fserror"><a class="header" href="#fserror">FsError</a></h2>
<p>The core error type used by all traits:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::FsError;
use std::path::Path;

fn handle_error(e: FsError) {
    match e {
        FsError::NotFound { path, operation } =&gt; {
            println!("{} not found during {}", path.display(), operation);
        }
        FsError::AlreadyExists { path, operation } =&gt; {
            println!("{} already exists during {}", path.display(), operation);
        }
        FsError::PermissionDenied { path, operation } =&gt; {
            println!("Permission denied: {} during {}", path.display(), operation);
        }
        FsError::Io { source, path, operation } =&gt; {
            println!("IO error on {}: {} during {}", 
                path.map(|p| p.display().to_string()).unwrap_or_default(),
                source, operation);
        }
        // ... handle other variants
    }
}
<span class="boring">}</span></code></pre>
<h2 id="error-variants"><a class="header" href="#error-variants">Error Variants</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Variant</th><th>When Used</th><th>Required Fields</th></tr>
</thead>
<tbody>
<tr><td><code>NotFound</code></td><td>File or directory doesn’t exist</td><td><code>path</code>, <code>operation</code></td></tr>
<tr><td><code>AlreadyExists</code></td><td>Creating something that exists</td><td><code>path</code>, <code>operation</code></td></tr>
<tr><td><code>PermissionDenied</code></td><td>Access not allowed</td><td><code>path</code>, <code>operation</code></td></tr>
<tr><td><code>IsDirectory</code></td><td>Expected file, got directory</td><td><code>path</code>, <code>operation</code></td></tr>
<tr><td><code>NotDirectory</code></td><td>Expected directory, got file</td><td><code>path</code>, <code>operation</code></td></tr>
<tr><td><code>DirectoryNotEmpty</code></td><td>Removing non-empty directory</td><td><code>path</code>, <code>operation</code></td></tr>
<tr><td><code>InvalidPath</code></td><td>Malformed path</td><td><code>path</code>, <code>operation</code>, <code>reason</code></td></tr>
<tr><td><code>TooManySymlinks</code></td><td>Symlink loop detected</td><td><code>path</code>, <code>operation</code></td></tr>
<tr><td><code>ReadOnly</code></td><td>Write on read-only filesystem</td><td><code>path</code>, <code>operation</code></td></tr>
<tr><td><code>CrossDevice</code></td><td>Cross-filesystem operation</td><td><code>source</code>, <code>destination</code>, <code>operation</code></td></tr>
<tr><td><code>Io</code></td><td>General I/O error</td><td><code>source</code>, <code>path</code> (optional), <code>operation</code></td></tr>
<tr><td><code>Other</code></td><td>Unclassified errors</td><td><code>message</code>, <code>operation</code></td></tr>
</tbody>
</table>
</div>
<h2 id="creating-errors"><a class="header" href="#creating-errors">Creating Errors</a></h2>
<p>Use the constructor methods for clean error creation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::FsError;
use std::path::Path;

// NotFound
let err = FsError::not_found(Path::new("/missing.txt"), "read");

// AlreadyExists
let err = FsError::already_exists(Path::new("/exists"), "create_dir");

// PermissionDenied
let err = FsError::permission_denied(Path::new("/secret"), "read");

// IsDirectory
let err = FsError::is_directory(Path::new("/folder"), "read");

// NotDirectory
let err = FsError::not_directory(Path::new("/file.txt"), "read_dir");

// DirectoryNotEmpty
let err = FsError::directory_not_empty(Path::new("/folder"), "remove_dir");

// InvalidPath
let err = FsError::invalid_path(
    Path::new("/bad\0path"),
    "contains null byte",
    "open"
);

// ReadOnly
let err = FsError::read_only(Path::new("/file.txt"), "write");

// IO error
let err = FsError::io(
    std::io::Error::new(std::io::ErrorKind::Other, "disk full"),
    Some(Path::new("/file.txt")),
    "write"
);
<span class="boring">}</span></code></pre>
<h2 id="error-conversion"><a class="header" href="#error-conversion">Error Conversion</a></h2>
<h3 id="from-stdioerror"><a class="header" href="#from-stdioerror">From std::io::Error</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::FsError;
use std::io;

fn from_io_error(e: io::Error, path: &amp;Path, op: &amp;str) -&gt; FsError {
    FsError::io(e, Some(path), op)
}

// Or use From trait (without path context)
let io_err = io::Error::new(io::ErrorKind::NotFound, "not found");
let fs_err: FsError = io_err.into();
<span class="boring">}</span></code></pre>
<h3 id="to-stdioerror"><a class="header" href="#to-stdioerror">To std::io::Error</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::FsError;
use std::io;

let fs_err = FsError::not_found(Path::new("/missing"), "read");
let io_err: io::Error = fs_err.into();

assert_eq!(io_err.kind(), io::ErrorKind::NotFound);
<span class="boring">}</span></code></pre>
<h2 id="error-display"><a class="header" href="#error-display">Error Display</a></h2>
<p>All errors implement <code>Display</code> with helpful messages:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let err = FsError::not_found(Path::new("/file.txt"), "read");
println!("{}", err);
// Output: not found: /file.txt (during read)

let err = FsError::permission_denied(Path::new("/secret"), "open");
println!("{}", err);
// Output: permission denied: /secret (during open)
<span class="boring">}</span></code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-always-include-operation-context"><a class="header" href="#1-always-include-operation-context">1. Always Include Operation Context</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✓ Good - includes operation
FsError::not_found(path, "read")

// ✗ Bad - no context
FsError::NotFound { path: path.into(), operation: String::new() }
<span class="boring">}</span></code></pre>
<h3 id="2-include-path-when-available"><a class="header" href="#2-include-path-when-available">2. Include Path When Available</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✓ Good - includes path
FsError::io(e, Some(path), "write")

// ✗ Avoid - loses context
FsError::io(e, None, "write")
<span class="boring">}</span></code></pre>
<h3 id="3-use-specific-error-types"><a class="header" href="#3-use-specific-error-types">3. Use Specific Error Types</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✓ Good - specific error
if path.exists() {
    return Err(FsError::already_exists(path, "create"));
}

// ✗ Avoid - generic error
return Err(FsError::other("file exists", "create"));
<span class="boring">}</span></code></pre>
<h3 id="4-pattern-match-for-handling"><a class="header" href="#4-pattern-match-for-handling">4. Pattern Match for Handling</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match fs.read(path) {
    Ok(data) =&gt; process(data),
    Err(FsError::NotFound { .. }) =&gt; create_default(),
    Err(FsError::PermissionDenied { .. }) =&gt; request_access(),
    Err(e) =&gt; return Err(e),
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="core-types"><a class="header" href="#core-types">Core Types</a></h1>
<p>This reference documents the core types used throughout AnyFS.</p>
<h2 id="metadata"><a class="header" href="#metadata">Metadata</a></h2>
<p>File and directory metadata:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::Metadata;

let meta = fs.metadata(path)?;

// Check type
if meta.is_file() {
    println!("Size: {} bytes", meta.len());
} else if meta.is_dir() {
    println!("Directory");
} else if meta.is_symlink() {
    println!("Symlink");
}

// Timestamps (optional - may be None for some backends)
if let Some(created) = meta.created() {
    println!("Created: {:?}", created);
}
if let Some(modified) = meta.modified() {
    println!("Modified: {:?}", modified);
}
if let Some(accessed) = meta.accessed() {
    println!("Accessed: {:?}", accessed);
}

// Permissions (if available)
if let Some(perms) = meta.permissions() {
    println!("Readonly: {}", perms.readonly());
}
<span class="boring">}</span></code></pre>
<h3 id="metadata-fields"><a class="header" href="#metadata-fields">Metadata Fields</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>file_type</code></td><td><code>FileType</code></td><td>File, directory, or symlink</td></tr>
<tr><td><code>len</code></td><td><code>u64</code></td><td>Size in bytes (0 for directories)</td></tr>
<tr><td><code>created</code></td><td><code>Option&lt;SystemTime&gt;</code></td><td>Creation time</td></tr>
<tr><td><code>modified</code></td><td><code>Option&lt;SystemTime&gt;</code></td><td>Last modification</td></tr>
<tr><td><code>accessed</code></td><td><code>Option&lt;SystemTime&gt;</code></td><td>Last access</td></tr>
<tr><td><code>permissions</code></td><td><code>Option&lt;Permissions&gt;</code></td><td>Permission info</td></tr>
</tbody>
</table>
</div>
<h3 id="creating-metadata"><a class="header" href="#creating-metadata">Creating Metadata</a></h3>
<p>For backend implementations:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::{Metadata, FileType, Permissions};
use std::time::SystemTime;

// File metadata
let meta = Metadata::file(1024)
    .with_created(SystemTime::now())
    .with_modified(SystemTime::now())
    .with_permissions(Permissions::readonly(false));

// Directory metadata
let meta = Metadata::dir()
    .with_modified(SystemTime::now());

// Symlink metadata
let meta = Metadata::symlink()
    .with_modified(SystemTime::now());
<span class="boring">}</span></code></pre>
<h2 id="filetype"><a class="header" href="#filetype">FileType</a></h2>
<p>Enumeration of filesystem entry types:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::FileType;

let ft = metadata.file_type();

match ft {
    FileType::File =&gt; println!("Regular file"),
    FileType::Dir =&gt; println!("Directory"),
    FileType::Symlink =&gt; println!("Symbolic link"),
}

// Convenience methods
assert!(FileType::File.is_file());
assert!(FileType::Dir.is_dir());
assert!(FileType::Symlink.is_symlink());
<span class="boring">}</span></code></pre>
<h2 id="direntry"><a class="header" href="#direntry">DirEntry</a></h2>
<p>Entry returned when reading directories:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::DirEntry;

for entry in fs.read_dir(path)? {
    let entry = entry?;
    
    // Name of the entry (not full path)
    println!("Name: {}", entry.name());
    
    // Full path
    println!("Path: {}", entry.path().display());
    
    // Type (if available without extra syscall)
    if let Some(ft) = entry.file_type() {
        println!("Type: {:?}", ft);
    }
    
    // Full metadata (may require extra syscall)
    let meta = entry.metadata()?;
    println!("Size: {}", meta.len());
}
<span class="boring">}</span></code></pre>
<h3 id="direntry-fields"><a class="header" href="#direntry-fields">DirEntry Fields</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Return Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>name()</code></td><td><code>&amp;str</code></td><td>Entry name (not path)</td></tr>
<tr><td><code>path()</code></td><td><code>&amp;Path</code></td><td>Full path</td></tr>
<tr><td><code>file_type()</code></td><td><code>Option&lt;FileType&gt;</code></td><td>Type if known cheaply</td></tr>
<tr><td><code>metadata()</code></td><td><code>Result&lt;Metadata, FsError&gt;</code></td><td>Full metadata</td></tr>
</tbody>
</table>
</div>
<h2 id="permissions"><a class="header" href="#permissions">Permissions</a></h2>
<p>File permission information:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::Permissions;

// Create permissions
let perms = Permissions::readonly(false);  // read-write
let perms = Permissions::readonly(true);   // read-only

// Check permissions
if perms.readonly() {
    println!("File is read-only");
}

// POSIX mode (if supported)
#[cfg(unix)]
{
    let perms = Permissions::from_mode(0o755);
    println!("Mode: {:o}", perms.mode());
}
<span class="boring">}</span></code></pre>
<h3 id="extended-permissions-unix"><a class="header" href="#extended-permissions-unix">Extended Permissions (Unix)</a></h3>
<p>For backends that support POSIX permissions:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::Permissions;

// From mode bits
let perms = Permissions::from_mode(0o644);

// Check mode
let mode = perms.mode();  // 0o644

// Permission bits
let owner_read = (mode &amp; 0o400) != 0;
let owner_write = (mode &amp; 0o200) != 0;
let owner_exec = (mode &amp; 0o100) != 0;
<span class="boring">}</span></code></pre>
<h2 id="openoptions"><a class="header" href="#openoptions">OpenOptions</a></h2>
<p>Options for opening files:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::OpenOptions;

// Read only (default)
let opts = OpenOptions::new().read(true);

// Write, create if missing
let opts = OpenOptions::new()
    .write(true)
    .create(true);

// Append mode
let opts = OpenOptions::new()
    .append(true)
    .create(true);

// Create new (fail if exists)
let opts = OpenOptions::new()
    .write(true)
    .create_new(true);

// Truncate existing
let opts = OpenOptions::new()
    .write(true)
    .truncate(true);
<span class="boring">}</span></code></pre>
<h3 id="openoptions-fields"><a class="header" href="#openoptions-fields">OpenOptions Fields</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>read(bool)</code></td><td><code>true</code></td><td>Open for reading</td></tr>
<tr><td><code>write(bool)</code></td><td><code>false</code></td><td>Open for writing</td></tr>
<tr><td><code>append(bool)</code></td><td><code>false</code></td><td>Append to end</td></tr>
<tr><td><code>create(bool)</code></td><td><code>false</code></td><td>Create if missing</td></tr>
<tr><td><code>create_new(bool)</code></td><td><code>false</code></td><td>Create, fail if exists</td></tr>
<tr><td><code>truncate(bool)</code></td><td><code>false</code></td><td>Truncate to zero length</td></tr>
</tbody>
</table>
</div>
<h2 id="seekfrom"><a class="header" href="#seekfrom">SeekFrom</a></h2>
<p>Position for seeking within files:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::SeekFrom;

// From start of file
let pos = SeekFrom::Start(100);

// From end of file (negative offset)
let pos = SeekFrom::End(-50);

// From current position
let pos = SeekFrom::Current(25);
<span class="boring">}</span></code></pre>
<p>Used with file handles:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{Read, Seek, SeekFrom};

let mut handle = fs.open_read(path)?;

// Jump to offset 100
handle.seek(SeekFrom::Start(100))?;

// Read from there
let mut buf = [0u8; 50];
handle.read(&amp;mut buf)?;
<span class="boring">}</span></code></pre>
<h2 id="filetimes"><a class="header" href="#filetimes">FileTimes</a></h2>
<p>For setting file timestamps:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::FileTimes;
use std::time::SystemTime;

let times = FileTimes::new()
    .set_accessed(SystemTime::now())
    .set_modified(SystemTime::now());

fs.set_times(path, times)?;
<span class="boring">}</span></code></pre>
<h2 id="fsstats-1"><a class="header" href="#fsstats-1">FsStats</a></h2>
<p>Filesystem statistics (capacity, usage):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::FsStats;

let stats: FsStats = fs.stats()?;

println!("Total: {} bytes", stats.total_bytes);
println!("Free: {} bytes", stats.free_bytes);
println!("Available: {} bytes", stats.available_bytes);
println!("Used: {}%", 
    (stats.total_bytes - stats.available_bytes) * 100 / stats.total_bytes
);
<span class="boring">}</span></code></pre>
<h3 id="fsstats-fields"><a class="header" href="#fsstats-fields">FsStats Fields</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>total_bytes</code></td><td><code>u64</code></td><td>Total capacity</td></tr>
<tr><td><code>free_bytes</code></td><td><code>u64</code></td><td>Free space</td></tr>
<tr><td><code>available_bytes</code></td><td><code>u64</code></td><td>Available to non-root</td></tr>
<tr><td><code>total_inodes</code></td><td><code>Option&lt;u64&gt;</code></td><td>Total inodes (Unix)</td></tr>
<tr><td><code>free_inodes</code></td><td><code>Option&lt;u64&gt;</code></td><td>Free inodes (Unix)</td></tr>
</tbody>
</table>
</div>
<h2 id="inodeid"><a class="header" href="#inodeid">InodeId</a></h2>
<p>Unique identifier for files (used by FsInode trait):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyfs_backend::InodeId;

let inode = fs.inode(path)?;
println!("Inode: {}", inode);

// Compare inodes to check if same file
let inode1 = fs.inode(path1)?;
let inode2 = fs.inode(path2)?;
if inode1 == inode2 {
    println!("Same file (hard links)");
}
<span class="boring">}</span></code></pre>
<h2 id="summary-10"><a class="header" href="#summary-10">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Metadata</code></td><td>File/directory attributes</td></tr>
<tr><td><code>FileType</code></td><td>File, Dir, or Symlink</td></tr>
<tr><td><code>DirEntry</code></td><td>Directory listing entry</td></tr>
<tr><td><code>Permissions</code></td><td>Access permissions</td></tr>
<tr><td><code>OpenOptions</code></td><td>File open configuration</td></tr>
<tr><td><code>FileTimes</code></td><td>Timestamp modification</td></tr>
<tr><td><code>FsStats</code></td><td>Filesystem capacity</td></tr>
<tr><td><code>InodeId</code></td><td>Unique file identifier</td></tr>
<tr><td><code>FsError</code></td><td>Error handling (see <a href="#error-types">Errors</a>)</td></tr>
</tbody>
</table>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>


        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace-2a3cd908.js"></script>
        <script src="mode-rust-2c9d5c9a.js"></script>
        <script src="editor-16ca416c.js"></script>
        <script src="theme-dawn-4493f9c8.js"></script>
        <script src="theme-tomorrow_night-9dbe62a9.js"></script>

        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
